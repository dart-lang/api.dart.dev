{"name":"package:unittest/unittest.dart","children":[{"returnType":{"name":"void","refId":"void"},"name":"disableTest","children":[{"ref":{"name":"int","refId":"dart.core/int"},"name":"testId","kind":"param","id":"testId"}],"kind":"method","comment":"Disable a test by ID. ","id":"disableTest1()","line":"907"},{"returnType":{"name":"void","refId":"void"},"name":"enableTest","children":[{"ref":{"name":"int","refId":"dart.core/int"},"name":"testId","kind":"param","id":"testId"}],"kind":"method","comment":"Enable a test by ID. ","id":"enableTest1()","line":"904"},{"returnType":{"name":"void","refId":"void"},"name":"_setTestEnabledState","children":[{"ref":{"name":"int","refId":"dart.core/int"},"name":"testId","kind":"param","id":"testId"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"state","kind":"param","id":"state"}],"isPrivate":true,"kind":"method","comment":"Enable/disable a test by ID. ","id":"_setTestEnabledState2()","line":"889"},{"returnType":{"name":"void","refId":"void"},"name":"setSoloTest","children":[{"ref":{"name":"int","refId":"dart.core/int"},"name":"id","kind":"param","id":"id"}],"kind":"method","comment":"Select a solo test by ID. ","id":"setSoloTest1()","line":"879"},{"name":"ensureInitialized","kind":"method","comment":"\nLazily initializes the test library if not already initialized.\n","id":"ensureInitialized0()","line":"854"},{"returnType":{"name":"void","refId":"void"},"name":"fail","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"param","id":"message"}],"kind":"method","id":"fail1()","line":"847"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"_fullSpec","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"spec","kind":"param","id":"spec"}],"isPrivate":true,"kind":"method","id":"_fullSpec1()","line":"842"},{"name":"_completeTests","isPrivate":true,"kind":"method","comment":"Publish results on the page and notify controller. ","id":"_completeTests0()","line":"823"},{"name":"_nextBatch","isPrivate":true,"kind":"method","comment":"\nRuns a batch of tests, yielding whenever an asynchronous test starts\nrunning. Tests will resume executing when such asynchronous test calls\n[done] or if it fails with an exception.\n","id":"_nextBatch0()","line":"804"},{"name":"_registerException","children":[{"name":"testNum","kind":"param","id":"testNum"},{"name":"e","kind":"param","id":"e"},{"isOptional":true,"name":"trace","kind":"param","id":"trace"}],"isPrivate":true,"kind":"method","comment":"\nRegisters that an exception was caught for the current test.\n","id":"_registerException3()","line":"785"},{"name":"registerException","children":[{"name":"e","kind":"param","id":"e"},{"isOptional":true,"name":"trace","kind":"param","id":"trace"}],"kind":"method","comment":"\nRegisters that an exception was caught for the current test.\n","id":"registerException2()","line":"778"},{"name":"guardAsync","children":[{"name":"tryBody","kind":"param","id":"tryBody"},{"isOptional":true,"name":"finallyBody","kind":"param","id":"finallyBody"},{"defaultValue":"-1","isOptional":true,"name":"testNum","kind":"param","id":"testNum"}],"kind":"method","comment":"\nRun [tryBody] guarded in a try-catch block. If an exception is thrown, update\nthe [_currentTest] status accordingly.\n","id":"guardAsync3()","line":"764"},{"name":"runTests","kind":"method","comment":"Runs all queued tests, one at a time. ","id":"runTests0()","line":"744"},{"returnType":{"name":"void","refId":"void"},"name":"filterTests","children":[{"name":"testFilter","kind":"param","id":"testFilter"}],"kind":"method","comment":"\nFilter the tests. [testFilter] can be a [RegExp], a [String] or a\npredicate function. This is different to enabling/disabling tests\nin that it removes the tests completely.\n","id":"filterTests1()","line":"730"},{"name":"rerunTests","kind":"method","id":"rerunTests0()","line":"719"},{"name":"_defer","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","children":[{"returnType":{"name":"void","refId":"void"},"name":"Function","uri":"sdk/lib/core/function.dart","kind":"functiontype","id":"Function","line":"13"}],"kind":"param","id":"callback"}],"isPrivate":true,"kind":"method","comment":"Runs [callback] at the end of the event loop. ","id":"_defer1()","line":"707"},{"returnType":{"name":"void","refId":"void"},"name":"_reportTestError","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"msg","kind":"param","id":"msg"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"trace","kind":"param","id":"trace"}],"isPrivate":true,"kind":"method","comment":"\nUtility function that can be used to notify the test framework that an\n error was caught outside of this library.\n","id":"_reportTestError2()","line":"694"},{"returnType":{"name":"void","refId":"void"},"name":"callbackDone","kind":"method","comment":"\nTemporary hack: expose old API.\nTODO(gram) remove this when WebKit tests are working with new framework\n","id":"callbackDone0()","line":"686"},{"returnType":{"name":"void","refId":"void"},"name":"_nextTestCase","isPrivate":true,"kind":"method","comment":"Advance to the next test case. ","id":"_nextTestCase0()","line":"677"},{"returnType":{"name":"void","refId":"void"},"name":"_handleCallbackFunctionComplete","children":[{"name":"testNum","kind":"param","id":"testNum"}],"isPrivate":true,"kind":"method","comment":"\nCalled when one of the callback functions is done with all expected\ncalls.\n","id":"_handleCallbackFunctionComplete1()","line":"644"},{"returnType":{"name":"void","refId":"void"},"name":"tearDown","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"teardownTest","kind":"param","id":"teardownTest"}],"kind":"method","comment":"\nRegister a [tearDown] function for a test [group]. This function will\nbe called after each test in the group is run. Note that if groups\nare nested only the most locally scoped [tearDown] function will be run.\n[setUp] and [tearDown] should be called within the [group] before any\ncalls to [test].\n","id":"tearDown1()","line":"636"},{"returnType":{"name":"void","refId":"void"},"name":"setUp","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"setupTest","kind":"param","id":"setupTest"}],"kind":"method","comment":"\nRegister a [setUp] function for a test [group]. This function will\nbe called before each test in the group is run. Note that if groups\nare nested only the most locally scoped [setUp] function will be run.\n[setUp] and [tearDown] should be called within the [group] before any\ncalls to [test].\n","id":"setUp1()","line":"625"},{"returnType":{"name":"void","refId":"void"},"name":"group","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"description","kind":"param","id":"description"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"body","children":[{"returnType":{"name":"void","refId":"void"},"name":"Function","uri":"sdk/lib/core/function.dart","kind":"functiontype","id":"Function","line":"13"}],"kind":"param","id":"body"}],"kind":"method","comment":"\nCreates a new named group of tests. Calls to group() or test() within the\nbody of the function passed to this will inherit this group's description.\n","id":"group2()","line":"586"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"protectAsync2","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"}],"kind":"method","comment":"\nLike [protectAsync0] but [callback] should take 2 positional arguments.\n","id":"protectAsync21()","line":"578"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"protectAsync1","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"}],"kind":"method","comment":"\nLike [protectAsync0] but [callback] should take 1 positional argument.\n","id":"protectAsync11()","line":"570"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"protectAsync0","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"}],"kind":"method","comment":"\nWraps the [callback] in a new function and returns that function. The new\nfunction will be able to handle exceptions by directing them to the correct\ntest. This is thus similar to expectAsync0. Use it to wrap any callbacks that\nmight optionally be called but may never be called during the test.\n[callback] should take 0 positional arguments (named arguments are not\nsupported).\n","id":"protectAsync01()","line":"562"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"_protectAsync","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"}],"isPrivate":true,"kind":"method","comment":"\nWraps the [callback] in a new function and returns that function. The new\nfunction will be able to handle exceptions by directing them to the correct\ntest. This is thus similar to expectAsync0. Use it to wrap any callbacks that\nmight optionally be called but may never be called during the test.\n[callback] should take between 0 and 4 positional arguments (named arguments\nare not supported).\n","id":"_protectAsync1()","line":"549"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"expectAsyncUntil2","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"isDone","kind":"param","id":"isDone"}],"kind":"method","comment":"\nLike [expectAsyncUntil0] but [callback] should take 2 positional arguments.\n","id":"expectAsyncUntil22()","line":"537"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"expectAsyncUntil1","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"isDone","kind":"param","id":"isDone"}],"kind":"method","comment":"\nLike [expectAsyncUntil0] but [callback] should take 1 positional argument.\n","id":"expectAsyncUntil12()","line":"529"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"expectAsyncUntil0","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"isDone","kind":"param","id":"isDone"}],"kind":"method","comment":"\nIndicate that [callback] is expected to be called until [isDone] returns\ntrue. The unittest framework check [isDone] after each callback and only\nwhen it returns true will it continue with the following test. Using\n[expectAsyncUntil0] will also ensure that errors that occur within\n[callback] are tracked and reported. [callback] should take 0 positional\narguments (named arguments are not supported).\n","id":"expectAsyncUntil02()","line":"521"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"_expectAsyncUntil","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"isDone","kind":"param","id":"isDone"}],"isPrivate":true,"kind":"method","comment":"\nIndicate that [callback] is expected to be called until [isDone] returns\ntrue. The unittest framework checks [isDone] after each callback and only\nwhen it returns true will it continue with the following test. Using\n[expectAsyncUntil] will also ensure that errors that occur within\n[callback] are tracked and reported. [callback] should take between 0 and\n4 positional arguments (named arguments are not supported).\n","id":"_expectAsyncUntil2()","line":"508"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"expectAsync2","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"int","refId":"dart.core/int"},"isNamed":true,"defaultValue":"1","isOptional":true,"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"Like [expectAsync0] but [callback] should take 2 positional arguments. ","id":"expectAsync22()","line":"496"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"expectAsync1","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"int","refId":"dart.core/int"},"isNamed":true,"defaultValue":"1","isOptional":true,"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"Like [expectAsync0] but [callback] should take 1 positional argument. ","id":"expectAsync12()","line":"490"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"expectAsync0","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"int","refId":"dart.core/int"},"isNamed":true,"defaultValue":"1","isOptional":true,"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"\nIndicate that [callback] is expected to be called a [count] number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified [count] times before it continues with the following test.  Using\n[expectAsync0] will also ensure that errors that occur within [callback] are\ntracked and reported. [callback] should take 0 positional arguments (named\narguments are not supported).\n","id":"expectAsync02()","line":"484"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"_expectAsync","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"int","refId":"dart.core/int"},"isNamed":true,"defaultValue":"1","isOptional":true,"name":"count","kind":"param","id":"count"}],"isPrivate":true,"kind":"method","comment":"\nIndicate that [callback] is expected to be called a [count] number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified [count] times before it continues with the following test.  Using\n[_expectAsync] will also ensure that errors that occur within [callback] are\ntracked and reported. [callback] should take between 0 and 4 positional\narguments (named arguments are not supported here).\n","id":"_expectAsync2()","line":"471"},{"returnType":{"name":"void","refId":"void"},"name":"solo_test","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"spec","kind":"param","id":"spec"},{"ref":{"name":"TestFunction","refId":"unittest/TestFunction"},"name":"body","kind":"param","id":"body"}],"kind":"method","comment":"\nCreates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.\n\n\"solo_\" means that this will be the only test that is run. All other tests\nwill be skipped. This is a convenience function to let you quickly isolate\na single test by adding \"solo_\" before it to temporarily disable all other\ntests.\n","id":"solo_test2()","line":"303"},{"returnType":{"name":"void","refId":"void"},"name":"asyncTest","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"spec","kind":"param","id":"spec"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"callbacks","kind":"param","id":"callbacks"},{"ref":{"name":"TestFunction","refId":"unittest/TestFunction"},"name":"body","kind":"param","id":"body"}],"kind":"method","comment":"\n(Deprecated) Creates a new async test case with the given description\nand body. The description will include the descriptions of any surrounding\ngroup() calls.\n","id":"asyncTest3()","line":"280"},{"returnType":{"name":"void","refId":"void"},"name":"test","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"spec","kind":"param","id":"spec"},{"ref":{"name":"TestFunction","refId":"unittest/TestFunction"},"name":"body","kind":"param","id":"body"}],"kind":"method","comment":"\nCreates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.\n","id":"test2()","line":"269"},{"returnType":{"name":"void","refId":"void"},"name":"expectThrow","children":[{"name":"function","kind":"param","id":"function"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"name":"callback","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"Function","children":[{"name":"exception","uri":"pkg/unittest/lib/unittest.dart","kind":"param","id":"exception","line":"242"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","id":"Function","line":"13"}],"kind":"param","id":"callback"}],"kind":"method","comment":"\n(Deprecated) Evaluates the [function] and validates that it throws an\nexception. If [callback] is provided, then it will be invoked with the\nthrown exception. The callback may do any validation it wants. In addition,\nif it returns `false`, that also indicates an expectation failure.\n","id":"expectThrow2()","line":"242"},{"name":"testCases","kind":"method","comment":"Get the list of tests. ","id":"testCases0()","line":"193"},{"returnType":{"name":"void","refId":"void"},"name":"logMessage","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"param","id":"message"}],"kind":"method","id":"logMessage1()","line":"178"},{"returnType":{"name":"Configuration","refId":"unittest/Configuration"},"name":"configure","children":[{"ref":{"name":"Configuration","refId":"unittest/Configuration"},"name":"config","kind":"param","id":"config"}],"kind":"method","comment":"\nSet the [Configuration] used by the unittest library. Returns any\nprevious configuration.\nTODO: consider deprecating in favor of a setter now we have a getter.\n","id":"configure1()","line":"172"},{"returnType":{"name":"Configuration","refId":"unittest/Configuration"},"name":"config","kind":"method","id":"config0()","line":"165"},{"name":"testCases","kind":"property","comment":"Get the list of tests. ","id":"testCases","line":"193"},{"ref":{"name":"Configuration","refId":"unittest/Configuration"},"name":"config","kind":"property","id":"config","line":"165"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"testState","kind":"variable","id":"testState","line":"234"},{"ref":{"name":"TestCase","refId":"unittest/TestCase"},"name":"_soloTest","isPrivate":true,"kind":"variable","id":"_soloTest","line":"225"},{"name":"ERROR","kind":"variable","id":"ERROR","line":"222"},{"name":"FAIL","kind":"variable","id":"FAIL","line":"221"},{"name":"PASS","kind":"variable","id":"PASS","line":"220"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"_uncaughtErrorMessage","isPrivate":true,"kind":"variable","id":"_uncaughtErrorMessage","line":"213"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_initialized","isPrivate":true,"kind":"variable","id":"_initialized","line":"211"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"_currentTest","isPrivate":true,"kind":"variable","id":"_currentTest","line":"208"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_testTeardown","isPrivate":true,"kind":"variable","id":"_testTeardown","line":"205"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_testSetup","isPrivate":true,"kind":"variable","id":"_testSetup","line":"202"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_testRunner","isPrivate":true,"kind":"variable","id":"_testRunner","line":"199"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"TestCase","refId":"unittest/TestCase"}]},"name":"_tests","isPrivate":true,"kind":"variable","id":"_tests","line":"190"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"groupSep","kind":"variable","id":"groupSep","line":"187"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"_currentGroup","isPrivate":true,"kind":"variable","id":"_currentGroup","line":"184"},{"ref":{"name":"Configuration","refId":"unittest/Configuration"},"name":"_config","isPrivate":true,"kind":"variable","id":"_config","line":"163"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"TestCase","children":[{"isSetter":true,"name":"setUp=","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"value","kind":"param","id":"value"}],"kind":"method","id":"setUp=1()","line":"24"},{"isSetter":true,"name":"tearDown=","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"value","kind":"param","id":"value"}],"kind":"method","id":"tearDown=1()","line":"30"},{"returnType":{"name":"void","refId":"void"},"name":"run","kind":"method","id":"run0()","line":"71"},{"returnType":{"name":"void","refId":"void"},"name":"_complete","isPrivate":true,"kind":"method","id":"_complete0()","line":"86"},{"returnType":{"name":"void","refId":"void"},"name":"pass","kind":"method","id":"pass0()","line":"102"},{"returnType":{"name":"void","refId":"void"},"name":"fail","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"messageText","kind":"param","id":"messageText"},{"ref":{"name":"String","refId":"dart.core/String"},"defaultValue":"''","isOptional":true,"name":"stack","kind":"param","id":"stack"}],"kind":"method","id":"fail2()","line":"107"},{"returnType":{"name":"void","refId":"void"},"name":"error","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"messageText","kind":"param","id":"messageText"},{"ref":{"name":"String","refId":"dart.core/String"},"defaultValue":"''","isOptional":true,"name":"stack","kind":"param","id":"stack"}],"kind":"method","id":"error2()","line":"122"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"setUp","kind":"property","id":"setUp","line":"23"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"tearDown","kind":"property","id":"tearDown","line":"29"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"isComplete","kind":"property","id":"isComplete","line":"69"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"name":"id","kind":"variable","id":"id","line":"15"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"description","kind":"variable","id":"description","line":"18"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_setUp","isPrivate":true,"kind":"variable","id":"_setUp","line":"21"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_tearDown","isPrivate":true,"kind":"variable","id":"_tearDown","line":"27"},{"ref":{"name":"TestFunction","refId":"unittest/TestFunction"},"name":"test","kind":"variable","id":"test","line":"33"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"callbackFunctionsOutstanding","kind":"variable","id":"callbackFunctionsOutstanding","line":"39"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"variable","id":"message","line":"42"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"result","kind":"variable","id":"result","line":"47"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"stackTrace","kind":"variable","id":"stackTrace","line":"50"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"currentGroup","kind":"variable","id":"currentGroup","line":"53"},{"ref":{"name":"DateTime","refId":"dart.core/DateTime"},"name":"startTime","kind":"variable","id":"startTime","line":"55"},{"ref":{"name":"Duration","refId":"dart.core/Duration"},"name":"runningTime","kind":"variable","id":"runningTime","line":"57"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"enabled","kind":"variable","id":"enabled","line":"59"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_doneTeardown","isPrivate":true,"kind":"variable","id":"_doneTeardown","line":"61"},{"name":"TestCase","children":[{"initializedField":{"name":"id","refId":"unittest/TestCase/id"},"ref":{"name":"int","refId":"dart.core/int"},"name":"id","kind":"param","id":"id"},{"initializedField":{"name":"description","refId":"unittest/TestCase/description"},"ref":{"name":"String","refId":"dart.core/String"},"name":"description","kind":"param","id":"description"},{"initializedField":{"name":"test","refId":"unittest/TestCase/test"},"ref":{"name":"TestFunction","refId":"unittest/TestFunction"},"name":"test","kind":"param","id":"test"},{"initializedField":{"name":"callbackFunctionsOutstanding","refId":"unittest/TestCase/callbackFunctionsOutstanding"},"ref":{"name":"int","refId":"dart.core/int"},"name":"callbackFunctionsOutstanding","kind":"param","id":"callbackFunctionsOutstanding","line":"64"}],"kind":"constructor","id":"TestCase4()","line":"63"}],"uri":"pkg/unittest/lib/src/test_case.dart","kind":"class","comment":"\ntestcase.dart: this file is sourced by unittest.dart. It defines [TestCase]\nand assumes unittest defines the type [TestFunction].\n\nSummarizes information about a single test case. ","id":"TestCase","line":"13"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Configuration","children":[{"returnType":{"name":"void","refId":"void"},"name":"onInit","kind":"method","comment":"\nCalled as soon as the unittest framework becomes initialized. This is done\neven before tests are added to the test framework. It might be used to\ndetermine/debug errors that occur before the test harness starts executing.\nIt is also used to tell the vm or browser that tests are going to be run\nasynchronously and that the process should wait until they are done.\n","id":"onInit0()","line":"39"},{"returnType":{"name":"void","refId":"void"},"name":"onStart","kind":"method","comment":"Called as soon as the unittest framework starts running. ","id":"onStart0()","line":"45"},{"returnType":{"name":"void","refId":"void"},"name":"onTestStart","children":[{"ref":{"name":"TestCase","refId":"unittest/TestCase"},"name":"testCase","kind":"param","id":"testCase"}],"kind":"method","comment":"\nCalled when each test starts. Useful to show intermediate progress on\na test suite.\n","id":"onTestStart1()","line":"51"},{"returnType":{"name":"void","refId":"void"},"name":"onTestResult","children":[{"ref":{"name":"TestCase","refId":"unittest/TestCase"},"name":"testCase","kind":"param","id":"testCase"}],"kind":"method","comment":"\nCalled when each test is completed. Useful to show intermediate progress on\na test suite.\n","id":"onTestResult1()","line":"59"},{"returnType":{"name":"void","refId":"void"},"name":"logMessage","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"param","id":"message"}],"kind":"method","comment":"\nCan be called by tests to log status. Tests should use this\ninstead of print. Subclasses should not override this; they\nshould instead override logMessage which is passed the test case.\n","id":"logMessage1()","line":"68"},{"returnType":{"name":"void","refId":"void"},"name":"logTestCaseMessage","children":[{"ref":{"name":"TestCase","refId":"unittest/TestCase"},"name":"testCase","kind":"param","id":"testCase"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"param","id":"message"}],"kind":"method","comment":"\nHandles the logging of messages by a test case. The default in\nthis base configuration is to call print();\n","id":"logTestCaseMessage2()","line":"85"},{"returnType":{"name":"void","refId":"void"},"name":"onSummary","children":[{"ref":{"name":"int","refId":"dart.core/int"},"name":"passed","kind":"param","id":"passed"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"failed","kind":"param","id":"failed"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"errors","kind":"param","id":"errors"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"TestCase","refId":"unittest/TestCase"}]},"name":"results","kind":"param","id":"results"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"uncaughtError","kind":"param","id":"uncaughtError","line":"98"}],"kind":"method","comment":"\nCalled with the result of all test cases. The default implementation prints\nthe result summary using the built-in [print] command. Browser tests\ncommonly override this to reformat the output.\n\nWhen [uncaughtError] is not null, it contains an error that occured outside\nof tests (e.g. setting up the test).\n","id":"onSummary5()","line":"97"},{"returnType":{"name":"void","refId":"void"},"name":"onDone","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"success","kind":"param","id":"success"}],"kind":"method","comment":"\nCalled when the unittest framework is done running. [success] indicates\nwhether all tests passed successfully.\n","id":"onDone1()","line":"135"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"_indent","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"str","kind":"param","id":"str"}],"isPrivate":true,"kind":"method","id":"_indent1()","line":"145"},{"name":"handleExternalError","children":[{"name":"e","kind":"param","id":"e"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"param","id":"message"}],"kind":"method","comment":"Handle errors that happen outside the tests. ","id":"handleExternalError2()","line":"155"},{"returnType":{"name":"void","refId":"void"},"name":"notifyController","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"param","id":"message"}],"kind":"method","comment":"\nSend messages to the test controller code (see 'test_controller.js'). This\nis only needed to support browser tests with dart2js. Note: we could wrap\ntests and send the appropriate messages to the controller through the\nwrapper, but using wrappers has a noticeable overhead in the testing bots,\nso we use this approach instead.\n\nConfigurations that will not run in DRT (such as vm_config and\ncompact_vm_config), can safely override this method to avoid printing extra\nmesages in the console.\n","id":"notifyController1()","line":"170"},{"name":"_postMessage","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"param","id":"message"}],"isPrivate":true,"kind":"method","id":"_postMessage1()","line":"173"},{"name":"name","kind":"property","comment":"\nSubclasses can override this with something useful for diagnostics.\nParticularly useful in cases where we have parent/child configurations\nsuch as layout tests.\n","id":"name","line":"25"},{"name":"autoStart","kind":"property","comment":"\nIf true, then tests are started automatically (otherwise [runTests]\nmust be called explicitly after the tests are set up.\n","id":"autoStart","line":"30"},{"ref":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"_receivePort","isPrivate":true,"kind":"variable","id":"_receivePort","line":"17"},{"ref":{"name":"TestCase","refId":"unittest/TestCase"},"name":"currentTestCase","kind":"variable","id":"currentTestCase","line":"18"}],"uri":"pkg/unittest/lib/src/config.dart","kind":"class","comment":"\nHooks to configure the unittest library for different platforms. This class\nimplements the API in a platform-independent way. Tests that want to take\nadvantage of the platform can create a subclass and override methods from\nthis class.\n","id":"Configuration","line":"14"},{"returnType":{"name":"void","refId":"void"},"name":"TestFunction","kind":"typedef","comment":"Signature for a test function. ","id":"TestFunction","line":"910"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"_SpreadArgsHelper","children":[{"name":"_init","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"shouldCallBack","kind":"param","id":"shouldCallBack"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"isDone","kind":"param","id":"isDone"},{"defaultValue":"0","isOptional":true,"name":"expectedCalls","kind":"param","id":"expectedCalls","line":"335"}],"isPrivate":true,"kind":"method","id":"_init4()","line":"334"},{"name":"_after","isPrivate":true,"kind":"method","id":"_after0()","line":"373"},{"name":"_allCallsDone","isPrivate":true,"kind":"method","id":"_allCallsDone0()","line":"379"},{"name":"_always","isPrivate":true,"kind":"method","id":"_always0()","line":"381"},{"name":"invoke","children":[{"defaultValue":"_sentinel","isOptional":true,"name":"arg0","kind":"param","id":"arg0"},{"defaultValue":"_sentinel","isOptional":true,"name":"arg1","kind":"param","id":"arg1"},{"defaultValue":"_sentinel","isOptional":true,"name":"arg2","kind":"param","id":"arg2"},{"defaultValue":"_sentinel","isOptional":true,"name":"arg3","kind":"param","id":"arg3","line":"394"},{"defaultValue":"_sentinel","isOptional":true,"name":"arg4","kind":"param","id":"arg4","line":"394"}],"kind":"method","id":"invoke5()","line":"393"},{"name":"invoke0","kind":"method","id":"invoke00()","line":"419"},{"name":"invoke1","children":[{"name":"arg1","kind":"param","id":"arg1"}],"kind":"method","id":"invoke11()","line":"430"},{"name":"invoke2","children":[{"name":"arg1","kind":"param","id":"arg1"},{"name":"arg2","kind":"param","id":"arg2"}],"kind":"method","id":"invoke22()","line":"441"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"_checkCallCount","isPrivate":true,"kind":"method","comment":"Returns false if we exceded the number of expected calls. ","id":"_checkCallCount0()","line":"453"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_callback","isPrivate":true,"kind":"variable","id":"_callback","line":"325"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"_expectedCalls","isPrivate":true,"kind":"variable","id":"_expectedCalls","line":"326"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"_actualCalls","isPrivate":true,"kind":"variable","id":"_actualCalls","line":"327"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"_testNum","isPrivate":true,"kind":"variable","id":"_testNum","line":"328"},{"ref":{"name":"TestCase","refId":"unittest/TestCase"},"name":"_testCase","isPrivate":true,"kind":"variable","id":"_testCase","line":"329"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_shouldCallBack","isPrivate":true,"kind":"variable","id":"_shouldCallBack","line":"330"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"_isDone","isPrivate":true,"kind":"variable","id":"_isDone","line":"331"},{"isStatic":true,"name":"_sentinel","isPrivate":true,"kind":"variable","id":"_sentinel","line":"332"},{"name":"_SpreadArgsHelper","children":[{"name":"callback","kind":"param","id":"callback"},{"name":"shouldCallBack","kind":"param","id":"shouldCallBack"},{"name":"isDone","kind":"param","id":"isDone"}],"kind":"constructor","id":"_SpreadArgsHelper3()","line":"357"},{"name":"_SpreadArgsHelper.fixedCallCount","children":[{"name":"callback","kind":"param","id":"callback"},{"name":"expectedCalls","kind":"param","id":"expectedCalls"}],"kind":"constructor","id":"_SpreadArgsHelper.fixedCallCount2()","line":"361"},{"name":"_SpreadArgsHelper.variableCallCount","children":[{"name":"callback","kind":"param","id":"callback"},{"name":"isDone","kind":"param","id":"isDone"}],"kind":"constructor","id":"_SpreadArgsHelper.variableCallCount2()","line":"365"},{"name":"_SpreadArgsHelper.optionalCalls","children":[{"name":"callback","kind":"param","id":"callback"}],"kind":"constructor","id":"_SpreadArgsHelper.optionalCalls1()","line":"369"}],"isPrivate":true,"kind":"class","comment":"Simulates spread arguments using named arguments. ","id":"_SpreadArgsHelper","line":"324"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"_Sentinel","children":[{"name":"_Sentinel","kind":"constructor","id":"_Sentinel0()","line":"318"}],"isPrivate":true,"kind":"class","comment":"Sentinel value for [_SpreadArgsHelper]. ","id":"_Sentinel","line":"317"}],"uri":"pkg/unittest/lib/unittest.dart","kind":"library","comment":"\nA library for writing dart unit tests.\n\nTo import this library, use the pub package manager.\nCreate a pubspec.yaml file in your project and add\na dependency on unittest with the following lines:\n    dependencies:\n      unittest:\n        sdk: unittest\n\nThen run 'pub install' from your project directory or using\nthe DartEditor.\n\nPlease see [Pub Getting Started](http://pub.dartlang.org/doc)\nfor more details about the pub package manager.\n\n##Concepts##\n\n * Tests: Tests are specified via the top-level function [test], they can be\n   organized together using [group].\n * Checks: Test expectations can be specified via [expect]\n * Matchers: [expect] assertions are written declaratively using [Matcher]s\n * Configuration: The framework can be adapted by calling [configure] with a\n   [Configuration].  Common configurations can be found in this package\n   under: 'dom\\_config.dart' (deprecated), 'html\\_config.dart' (for running\n   tests compiled to Javascript in a browser), and 'vm\\_config.dart' (for\n   running native Dart tests on the VM).\n\n##Examples##\n\nA trivial test:\n\n    import 'package:unittest/unittest.dart';\n    main() {\n      test('this is a test', () {\n        int x = 2 + 3;\n        expect(x, equals(5));\n      });\n    }\n\nMultiple tests:\n\n    import 'package:unittest/unittest.dart';\n    main() {\n      test('this is a test', () {\n        int x = 2 + 3;\n        expect(x, equals(5));\n      });\n      test('this is another test', () {\n        int x = 2 + 3;\n        expect(x, equals(5));\n      });\n    }\n\nMultiple tests, grouped by category:\n\n    import 'package:unittest/unittest.dart';\n    main() {\n      group('group A', () {\n        test('test A.1', () {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        });\n        test('test A.2', () {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        });\n      });\n      group('group B', () {\n        test('this B.1', () {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        });\n      });\n    }\n\nAsynchronous tests: if callbacks expect between 0 and 2 positional arguments,\ndepending on the suffix of expectAsyncX(). expectAsyncX() will wrap a\nfunction into a new callback and will not consider the test complete until\nthat callback is run. A count argument can be provided to specify the number\nof times the callback should be called (the default is 1).\n\n    import 'package:unittest/unittest.dart';\n    import 'dart:isolate';\n    main() {\n      test('callback is executed once', () {\n        // wrap the callback of an asynchronous call with [expectAsync0] if\n        // the callback takes 0 arguments...\n        var timer = new Timer(0, (_) => expectAsync0(() {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        }));\n      });\n\n      test('callback is executed twice', () {\n        var callback = (_) => expectAsync0(() {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        }, count: 2); // <-- we can indicate multiplicity to [expectAsync0]\n        new Timer(0, callback);\n        new Timer(0, callback);\n      });\n    }\n\nexpectAsyncX() will wrap the callback code in a try/catch handler to handle\nexceptions (treated as test failures). There may be times when the number of\ntimes a callback should be called is non-deterministic. In this case a dummy\ncallback can be created with expectAsync0((){}) and this can be called from\nthe real callback when it is finally complete. In this case the body of the\ncallback should be protected within a call to guardAsync(); this will ensure\nthat exceptions are properly handled.\n\nNote: due to some language limitations we have to use different functions\ndepending on the number of positional arguments of the callback. In the\nfuture, we plan to expose a single `expectAsync` function that can be used\nregardless of the number of positional arguments. This requires new langauge\nfeatures or fixes to the current spec (e.g. see\n[Issue 2706](http://dartbug.com/2706)).\n\nMeanwhile, we plan to add this alternative API for callbacks of more than 2\narguments or that take named parameters. (this is not implemented yet,\nbut will be coming here soon).\n\n    import 'package:unittest/unittest.dart';\n    import 'dart:isolate';\n    main() {\n      test('callback is executed', () {\n        // indicate ahead of time that an async callback is expected.\n        var async = startAsync();\n        new Timer(0, (_) {\n          // Guard the body of the callback, so errors are propagated\n          // correctly.\n          guardAsync(() {\n            int x = 2 + 3;\n            expect(x, equals(5));\n          });\n          // indicate that the asynchronous callback was invoked.\n          async.complete();\n        });\n      });\n    }\n\n","id":"unittest","line":"148"}