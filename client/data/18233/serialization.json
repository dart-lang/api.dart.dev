{"name":"package:serialization/serialization.dart","children":[{"name":"_lazy","children":[{"name":"l","kind":"param","id":"l"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"method","comment":"Create a lazy list/map that will inflate its items on demand in [r]. ","id":"_lazy2()","line":"453"},{"superclass":{"name":"Format","refId":"serialization/Format"},"name":"SimpleFlatFormat","children":[{"returnType":{"name":"List","refId":"dart.core/List"},"name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nGenerate output for this format from [w]. This will return a List with\nthree entries, corresponding to the \"rules\", \"data\", and \"roots\" from\n[SimpleMapFormat]. The data is stored as a single List containing\nprimitives.\n","id":"generateOutput1()","line":"216"},{"returnType":{"name":"void","refId":"void"},"name":"writeStateInto","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"ruleData","kind":"param","id":"ruleData"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"target","kind":"param","id":"target"}],"kind":"method","comment":"\nWrites the data from [rule] into the [target] list.\n","id":"writeStateInto3()","line":"234"},{"name":"writeLists","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"entries","kind":"param","id":"entries"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"target","kind":"param","id":"target"}],"kind":"method","comment":"\nWrite [entries], which contains Lists. Either the lists are variable\nlength, in which case we add a length field, or they are fixed length, in\nwhich case we don't, and assume the [rule] will know how to read the\nright length when we read it back. We expect everything in the list to be\na reference, which is stored as two numbers.\n","id":"writeLists3()","line":"259"},{"name":"writeMaps","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Map","refId":"dart.core/Map"}]},"name":"entries","kind":"param","id":"entries"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"target","kind":"param","id":"target"}],"kind":"method","comment":"\nWrite [entries], which contains Maps. Either the Maps are variable\nlength, in which case we add a length field, or they are fixed length, in\nwhich case we don't, and assume the [rule] will know how to read the\nright length when we read it back. Then we write alternating keys and\nvalues. We expect the values to be references, which we store as\ntwo numbers.\n","id":"writeMaps3()","line":"279"},{"name":"writeObjects","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"entries","kind":"param","id":"entries"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"target","kind":"param","id":"target"}],"kind":"method","comment":"\nWrite [entries], which contains simple objects which we can put directly\ninto [target].\n","id":"writeObjects2()","line":"296"},{"returnType":{"name":"void","refId":"void"},"name":"writeReference","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"eachRef","kind":"param","id":"eachRef"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"target","kind":"param","id":"target"}],"kind":"method","comment":"\nWrite [eachRef] to [target]. It will be written as two ints. If [eachRef]\nis null it will be written as two nulls.\n","id":"writeReference2()","line":"308"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"read","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"rawInput","kind":"param","id":"rawInput"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"\nRead the data from [rawInput] in the context of [r] and return it as a\nMap with entries for \"roots\", \"data\" and \"rules\", which the reader knows\nhow to interpret. We expect [rawInput] to have been generated from this\nformat.\n","id":"read2()","line":"323"},{"name":"readRuleDataFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"\nRead the data for [rule] from [input] and return it.\n","id":"readRuleDataFrom3()","line":"352"},{"name":"readLists","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"length","kind":"param","id":"length"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"\nRead data for [rule] from [input] with [length] number of entries,\ncreating lists from the results.\n","id":"readLists4()","line":"375"},{"name":"readMaps","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"length","kind":"param","id":"length"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"\nRead data for [rule] from [input] with [length] number of entries,\ncreating maps from the results.\n","id":"readMaps4()","line":"393"},{"name":"readPrimitives","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"length","kind":"param","id":"length"}],"kind":"method","comment":"\nRead data for [rule] from [input] with [length] number of entries,\ntreating the data as primitives that can be returned directly.\n","id":"readPrimitives3()","line":"413"},{"name":"nextReferenceFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"Read the next Reference from the input. ","id":"nextReferenceFrom2()","line":"422"},{"name":"_next","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"input","kind":"param","id":"input"}],"isPrivate":true,"kind":"method","comment":"Return the next element from the input. ","id":"_next1()","line":"433"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferencesForPrimitives","kind":"property","id":"shouldUseReferencesForPrimitives","line":"200"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"isStatic":true,"name":"STORED_AS_LIST","kind":"variable","id":"STORED_AS_LIST","line":"206"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"isStatic":true,"name":"STORED_AS_MAP","kind":"variable","id":"STORED_AS_MAP","line":"207"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"isStatic":true,"name":"STORED_AS_PRIMITIVE","kind":"variable","id":"STORED_AS_PRIMITIVE","line":"208"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nWrites to a simple mostly-flat format. Details are subject to change.\nRight now this produces a List containing null, num, and String. This is\nmore space-efficient than the map formats, but much less human-readable.\nSimple usage is to turn this into JSON for transmission.\n","id":"SimpleFlatFormat","line":"199"},{"superclass":{"name":"Format","refId":"serialization/Format"},"name":"SimpleJsonFormat","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nGenerate output for this format from [w] and return it as a String which\nis the [json] representation of a nested Map structure.\n","id":"generateOutput1()","line":"109"},{"name":"jsonify","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nConvert the data generated by the rules to have nested maps instead\nof Reference objects and to add rule numbers if [storeRoundTripInfo]\nis true.\n","id":"jsonify1()","line":"119"},{"name":"jsonifyForRule","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"ruleData","kind":"param","id":"ruleData"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"kind":"method","comment":"\nFor a particular [rule] modify the [ruleData] to conform to this format.\n","id":"jsonifyForRule3()","line":"129"},{"name":"jsonifyEntry","children":[{"name":"map","kind":"param","id":"map"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nFor one particular entry, which is either a Map or a List, update it\nto turn References into a nested List/Map.\n","id":"jsonifyEntry2()","line":"146"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"read","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"\nRead a [json] encoded string representing serialized data in this format\nand return the Map representation that the reader expects, with top-level\nentries for \"rules\", \"data\", and \"roots\". Nested lists/maps will be\nconverted into Reference objects. Note that if the data was not written\nwith [storeRoundTripInfo] true this will fail.\n","id":"read2()","line":"159"},{"name":"recursivelyFixUp","children":[{"name":"data","kind":"param","id":"data"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"result","kind":"param","id":"result"}],"kind":"method","comment":"\nConvert nested references in [data] into [Reference] objects.\n","id":"recursivelyFixUp3()","line":"174"},{"isFinal":true,"ref":{"name":"bool","refId":"dart.core/bool"},"name":"storeRoundTripInfo","kind":"variable","id":"storeRoundTripInfo","line":"96"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"ruleIdentifier","kind":"variable","id":"ruleIdentifier","line":"101"},{"name":"SimpleJsonFormat","children":[{"initializedField":{"name":"storeRoundTripInfo","refId":"serialization/SimpleJsonFormat/storeRoundTripInfo"},"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"name":"storeRoundTripInfo","kind":"param","id":"storeRoundTripInfo"}],"kind":"constructor","id":"SimpleJsonFormat1()","line":"103"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nA format for \"normal\" JSON representation of objects. It stores\nthe fields of the objects as nested maps, and doesn't allow cycles. This can\nbe useful in talking to existing APIs that expect JSON format data. However,\nnote that since the classes of objects aren't stored, this isn't enough\ninformation to read back the objects. This format also doesn't support the\n[selfDescriptive] option on the [Serialization], as storing the rules.\nIf the [storeRoundTripData] field of the format is set to true, then this\nwill store the rule number along with the data, allowing reconstruction.\n","id":"SimpleJsonFormat","line":"88"},{"superclass":{"name":"Format","refId":"serialization/Format"},"name":"SimpleMapFormat","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nGenerate output for this format from [w] and return it as a String which\nis the [json] representation of a nested Map structure. The top level has\n3 fields, \"rules\" which may hold a definition of the rules used,\n\"data\" which holds the serialized data, and \"roots\", which holds\n[Reference] objects indicating the root objects. Note that roots are\nnecessary because the data is organized in the same way as the object\nstructure, it's a list of lists holding self-contained maps which only\nrefer to other parts via [Reference] objects.\nThis effectively defines a custom JSON serialization format, although\nthe details of the format vary depending which rules were used.\n","id":"generateOutput1()","line":"55"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"read","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nRead a [json] encoded string representing serialized data in this format\nand return the nested Map representation described in [generateOutput]. If\nthe data also includes rule definitions, then these will replace the rules\nin the [Serialization] for [reader].\n","id":"read2()","line":"70"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nA format that stores the data in maps which are converted into a JSON\nstring. Note that the maps aren't nested, and it handles cyclic references\nby converting object references to [Reference] objects. If you want simple\nacyclic JSON look at [SimpleJsonFormat].\n","id":"SimpleMapFormat","line":"41"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"Format","children":[{"name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nGenerate output for [w] and return it. The particular form of the output\nwill depend on the format. The format can assume that [w] has data\ngenerated by rules in a series of lists, and that each list will contain\neither primitives (null, bool, num, String), Lists or Maps. The Lists or\nMaps may contain any of the same things recursively, or may contain\nReference objects. For lists and maps the rule will tell us if they can\nbe of variable length or not. The format is allowed to operate\ndestructively on the rule data.\n","id":"generateOutput1()","line":"25"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"read","children":[{"name":"input","kind":"param","id":"input"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nRead the data from [input] in the context of [reader] and return it as a\nMap with entries for \"roots\", \"data\" and \"rules\", which the reader knows\nhow to interpret. The type of [input] will depend on the particular format.\n","id":"read2()","line":"32"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferencesForPrimitives","kind":"property","comment":"\nReturn true if this format stores primitives in their own area and uses\nreferences to them (e.g. [SimpleFlatFormat]) and false if primitives\nare stored directly (e.g. [SimpleJsonFormat], [SimpleMapFormat]).\n","id":"shouldUseReferencesForPrimitives","line":"13"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nAn abstract class for serialization formats. Subclasses define how data\nis read or written to a particular output mechanism.\n","id":"Format","line":"7"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"_MapWrapper","children":[{"isOperator":true,"name":"[]","children":[{"name":"key","kind":"param","id":"key"}],"kind":"method","id":"[]1()","line":"626"},{"isOperator":true,"name":"[]=","children":[{"name":"key","kind":"param","id":"key"},{"name":"value","kind":"param","id":"value"}],"kind":"method","id":"[]=2()","line":"628"},{"name":"asMap","kind":"method","id":"asMap0()","line":"631"},{"name":"length","kind":"property","id":"length","line":"629"},{"isFinal":true,"name":"_map","isPrivate":true,"kind":"variable","id":"_map","line":"621"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"fieldList","kind":"variable","id":"fieldList","line":"622"},{"name":"_MapWrapper","children":[{"initializedField":{"name":"fieldList","refId":"serialization/_MapWrapper/fieldList"},"ref":{"name":"List","refId":"dart.core/List"},"name":"fieldList","kind":"param","id":"fieldList"}],"kind":"constructor","id":"_MapWrapper1()","line":"623"},{"name":"_MapWrapper.fromMap","children":[{"initializedField":{"name":"_map","refId":"serialization/_MapWrapper/_map"},"name":"_map","isPrivate":true,"kind":"param","id":"_map"},{"initializedField":{"name":"fieldList","refId":"serialization/_MapWrapper/fieldList"},"ref":{"name":"List","refId":"dart.core/List"},"name":"fieldList","kind":"param","id":"fieldList"}],"kind":"constructor","id":"_MapWrapper.fromMap2()","line":"624"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis wraps a map to make it indexable by integer field numbers. It translates\nfrom the index into a field name and then looks it up in the map.\n","id":"_MapWrapper","line":"620"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Constructor","children":[{"name":"constructFrom","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"\nFind the field values in [state] and pass them to the constructor.\nIf any of [fieldNumbers] is not an int, then use it as a literal value.\n","id":"constructFrom2()","line":"607"},{"isFinal":true,"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"name":"type","kind":"variable","id":"type","line":"582"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"variable","id":"name","line":"585"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"name":"fieldNumbers","kind":"variable","id":"fieldNumbers","line":"592"},{"name":"Constructor","children":[{"initializedField":{"name":"type","refId":"serialization/Constructor/type"},"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"name":"type","kind":"param","id":"type"},{"initializedField":{"name":"name","refId":"serialization/Constructor/name"},"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"param","id":"name"},{"initializedField":{"name":"fieldNumbers","refId":"serialization/Constructor/fieldNumbers"},"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"name":"fieldNumbers","kind":"param","id":"fieldNumbers"}],"kind":"constructor","comment":"\nCreates a new constructor for the [type] with the constructor named [name]\nand the [fieldNumbers] of the constructor fields.\n","id":"Constructor3()","line":"598"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a constructor that is to be used when re-creating a\nserialized object.\n","id":"Constructor","line":"580"},{"name":"SetWithFunction","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"m","kind":"param","id":"m"},{"name":"object","kind":"param","id":"object"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"typedef","comment":"\n Provide a typedef for the setWith argument to setFieldWith. It would\nbe nice if we could put this closer to the definition.\n","id":"SetWithFunction","line":"574"},{"superclass":{"name":"Iterable","refId":"dart.core/Iterable"},"name":"_FieldList","children":[{"returnType":{"name":"_Field","refId":"serialization/_Field"},"name":"named","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"param","id":"name"}],"kind":"method","comment":"Look up a field by [name]. ","id":"named1()","line":"444"},{"isSetter":true,"name":"constructorFields=","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"fieldNames","kind":"param","id":"fieldNames"}],"kind":"method","comment":"Set the fields to be used in the constructor. ","id":"constructorFields=1()","line":"447"},{"isSetter":true,"name":"regular=","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"fields","kind":"param","id":"fields"}],"kind":"method","comment":"Set the fields that aren't used in the constructor. ","id":"regular=1()","line":"459"},{"isSetter":true,"name":"exclude=","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"fields","kind":"param","id":"fields"}],"kind":"method","comment":"Set the fields to be excluded. This is mutually exclusive with setting\nthe regular fields.\n","id":"exclude=1()","line":"468"},{"returnType":{"name":"void","refId":"void"},"name":"addAllNotExplicitlyExcluded","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"aCollection","kind":"param","id":"aCollection"}],"kind":"method","comment":"Add all the fields which aren't on the exclude list. ","id":"addAllNotExplicitlyExcluded1()","line":"480"},{"returnType":{"name":"void","refId":"void"},"name":"addAllByName","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"names","kind":"param","id":"names"}],"kind":"method","comment":"Add all the fields with the given names without any special properties. ","id":"addAllByName1()","line":"488"},{"returnType":{"name":"void","refId":"void"},"name":"invalidate","kind":"method","comment":"\nFields have been added. In case we had already forced calculation of the\nlist of contents, re-set it.\n","id":"invalidate0()","line":"499"},{"returnType":{"name":"void","refId":"void"},"name":"forEachRegularField","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","comment":"Iterate over the regular fields, i.e. those not used in the constructor.","id":"forEachRegularField1()","line":"517"},{"returnType":{"name":"void","refId":"void"},"name":"forEachConstructorField","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","comment":"Iterate over the fields used in the constructor. ","id":"forEachConstructorField1()","line":"526"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"constructorFieldNames","kind":"method","id":"constructorFieldNames0()","line":"535"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"constructorFieldIndices","kind":"method","id":"constructorFieldIndices0()","line":"537"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"regularFields","kind":"method","id":"regularFields0()","line":"539"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"regularFieldNames","kind":"method","id":"regularFieldNames0()","line":"540"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"regularFieldIndices","kind":"method","id":"regularFieldIndices0()","line":"541"},{"returnType":{"name":"void","refId":"void"},"name":"figureOutFields","kind":"method","comment":"\nIf we weren't given any non-constructor fields to use, figure out what\nwe think they ought to be, based on the class definition.\nWe find public fields, getters that have corresponding setters, and getters\nthat are listed in the constructor fields.\n","id":"figureOutFields0()","line":"550"},{"name":"toString","kind":"method","id":"toString0()","line":"567"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"length","kind":"property","id":"length","line":"477"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"iterator","kind":"property","id":"iterator","line":"504"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"_Field","refId":"serialization/_Field"}]},"name":"contents","kind":"property","comment":"Return a cached, sorted list of all the fields. ","id":"contents","line":"507"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"constructorFields","kind":"property","id":"constructorFields","line":"534"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"_Field","refId":"serialization/_Field"}]},"name":"allFields","kind":"variable","id":"allFields","line":"420"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"_constructorFields","isPrivate":true,"kind":"variable","id":"_constructorFields","line":"427"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"_excludeFields","isPrivate":true,"kind":"variable","id":"_excludeFields","line":"430"},{"isFinal":true,"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"name":"mirror","kind":"variable","id":"mirror","line":"433"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"_Field","refId":"serialization/_Field"}]},"name":"_contents","isPrivate":true,"kind":"variable","id":"_contents","line":"436"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_shouldFigureOutFields","isPrivate":true,"kind":"variable","id":"_shouldFigureOutFields","line":"439"},{"name":"_FieldList","children":[{"initializedField":{"name":"mirror","refId":"serialization/_FieldList/mirror"},"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"name":"mirror","kind":"param","id":"mirror"}],"kind":"constructor","id":"_FieldList1()","line":"441"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThe organization of fields in an object can be reasonably complex, so they\nare kept in a separate object, which also has the ability to compute the\ndefault fields to use reflectively.\n","id":"_FieldList","line":"415"},{"superclass":{"name":"_Field","refId":"serialization/_Field"},"name":"_ConstantField","children":[{"isOperator":true,"name":"==","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"==1()","line":"396"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","id":"toString0()","line":"398"},{"name":"valueIn","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"mirror","kind":"param","id":"mirror"}],"kind":"method","id":"valueIn1()","line":"399"},{"returnType":{"name":"void","refId":"void"},"name":"setValue","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"object","kind":"param","id":"object"},{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"We cannot be set, so setValue is a no-op. ","id":"setValue2()","line":"402"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"hashCode","kind":"property","id":"hashCode","line":"397"},{"name":"name","kind":"property","comment":"There are places where the code expects us to have an identifier, so\nuse the value for that.\n","id":"name","line":"407"},{"isFinal":true,"name":"value","kind":"variable","id":"value","line":"392"},{"name":"_ConstantField._internal","children":[{"initializedField":{"name":"value","refId":"serialization/_ConstantField/value"},"name":"value","kind":"param","id":"value"},{"name":"fieldList","kind":"param","id":"fieldList"}],"isPrivate":true,"kind":"constructor","id":"_ConstantField._internal2()","line":"394"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a constant value that will be passed as a constructor\nparameter. Rather than having a name it has a constant value.\n","id":"_ConstantField","line":"389"},{"superclass":{"name":"_Field","refId":"serialization/_Field"},"name":"_NamedField","children":[{"isOperator":true,"name":"==","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"==1()","line":"355"},{"returnType":{"name":"void","refId":"void"},"name":"setValue","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"object","kind":"param","id":"object"},{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Set the [value] of our field in the given mirrored [object]. ","id":"setValue2()","line":"366"},{"name":"valueIn","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"mirror","kind":"param","id":"mirror"}],"kind":"method","id":"valueIn1()","line":"370"},{"returnType":{"name":"void","refId":"void"},"name":"defaultSetter","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"object","kind":"param","id":"object"},{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Return a default setter function. ","id":"defaultSetter2()","line":"378"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","id":"toString0()","line":"382"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"hashCode","kind":"property","id":"hashCode","line":"356"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"isEssential","kind":"property","comment":"\nReturn true if this field is treated as essential state, either because\nit is used in the constructor, or because it's been designated\nusing [setFieldWith].\n","id":"isEssential","line":"363"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"setter","kind":"property","comment":"Return the function to use to set our value. ","id":"setter","line":"374"},{"isFinal":true,"name":"name","kind":"variable","id":"name","line":"348"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"customSetter","kind":"variable","id":"customSetter","line":"351"},{"name":"_NamedField._internal","children":[{"initializedField":{"name":"name","refId":"serialization/_NamedField/name"},"name":"name","kind":"param","id":"name"},{"name":"fieldList","kind":"param","id":"fieldList"}],"isPrivate":true,"kind":"constructor","id":"_NamedField._internal2()","line":"353"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a field in the object, either stored as a field or\naccessed via getter/setter/constructor parameter. It has a name and\nwill attempt to access the state for that name using an [InstanceMirror].\n","id":"_NamedField","line":"346"},{"interfaces":[{"name":"Comparable","refId":"dart.core/Comparable"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"_Field","children":[{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"_isReallyAField","children":[{"name":"value","kind":"param","id":"value"},{"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"name":"fieldList","kind":"param","id":"fieldList"}],"isPrivate":true,"kind":"method","comment":"\nDetermine if [value] represents a field or getter in the class that\n[fieldList] models.\n","id":"_isReallyAField2()","line":"305"},{"name":"valueIn","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"mirror","kind":"param","id":"mirror"}],"kind":"method","comment":"\nExtracts the value for the field that this represents from the instance\nmirrored by [mirror] and return it.\n","id":"valueIn1()","line":"318"},{"returnType":{"name":"void","refId":"void"},"name":"setValue","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"object","kind":"param","id":"object"},{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Set the [value] of our field in the given mirrored [object]. ","id":"setValue2()","line":"333"},{"name":"compareTo","children":[{"ref":{"name":"_Field","refId":"serialization/_Field"},"name":"x","kind":"param","id":"x"}],"kind":"method","id":"compareTo1()","line":"338"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"isRegular","kind":"property","comment":"Return true if this is field is not used in the constructor. ","id":"isRegular","line":"323"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"isEssential","kind":"property","comment":"\nReturn true if this field is treated as essential state, either because\nit is used in the constructor, or because it's been designated\nusing [setFieldWith].\n","id":"isEssential","line":"330"},{"isFinal":true,"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"name":"fieldList","kind":"variable","id":"fieldList","line":"277"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"index","kind":"variable","id":"index","line":"283"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"usedInConstructor","kind":"variable","id":"usedInConstructor","line":"286"},{"name":"_Field","children":[{"name":"value","kind":"param","id":"value"},{"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"name":"fieldList","kind":"param","id":"fieldList"}],"kind":"constructor","comment":"\nCreate a new [_Field] instance. This will be either a [_NamedField] or a\n[_ConstantField] depending on whether or not [value] corresponds to a\nfield in the class which [fieldList] models.\n","id":"_Field2()","line":"293"},{"name":"_Field._internal","children":[{"initializedField":{"name":"fieldList","refId":"serialization/_Field/fieldList"},"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"name":"fieldList","kind":"param","id":"fieldList"}],"isPrivate":true,"kind":"constructor","comment":"Private constructor. ","id":"_Field._internal1()","line":"312"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a field in an object. It is intended to be used as part of\na [_FieldList].\n","id":"_Field","line":"274"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"BasicRule","children":[{"name":"setFieldWith","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"fieldName","kind":"param","id":"fieldName"},{"ref":{"name":"SetWithFunction","refId":"serialization/SetWithFunction"},"name":"setWith","kind":"param","id":"setWith"}],"kind":"method","comment":"\nSometimes it's necessary to treat fields of an object differently, based\non the containing object. For example, by default a list treats its\ncontents as non-essential state, so it will be populated only after all\nobjects have been created. An object may have a list which is used in its\nconstructor and must be fully created before the owning object can be\ncreated. Alternatively, it may not be possible to set a field directly,\nand some other method must be called to set it, perhaps calling a method\non the owning object to add each individual element.\n\nThis method lets you designate a function to use to set the value of a\nfield. It also makes the contents of that field be treated as essential,\nwhich currently only has meaning if the field is a list. This is done\nbecause you might set a list field's special treatment function to add\neach item individually and that will only work if those objects already\nexist.\n\nFor example, to serialize a Serialization, we need its rules to be\nindividually added rather than just setting the rules field.\n     ..addRuleFor(new Serialization()).setFieldWith('rules',\n         (InstanceMirror s, List rules) {\n           rules.forEach((x) => s.reflectee.addRule(x));\nNote that the function is passed the owning object as well as the field\nvalue, but that it is passed as a mirror.\n","id":"setFieldWith2()","line":"95"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","id":"toString0()","line":"111"},{"name":"configureForMaps","kind":"method","comment":"\nConfigure this instance to use maps by field name as its output.\nInstances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","id":"configureForMaps0()","line":"119"},{"name":"configureForLists","kind":"method","comment":"\nConfigure this instance to use lists accessing fields by index as its\noutput. Instances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","id":"configureForLists0()","line":"129"},{"name":"createStateHolder","kind":"method","comment":"Create either a list or a map to hold the object's state, depending\non the [useMaps] variable. If using a Map, we wrap it in order to keep\nthe protocol compatible. See [configureForLists]/[configureForMaps].\n","id":"createStateHolder0()","line":"137"},{"name":"makeIndexableByNumber","children":[{"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"\nWrap the state if it's passed in as a map, and if the keys are references,\nresolve them to the strings we expect. We leave the previous keys in there\nas well, as they shouldn't be harmful, and it costs more to remove them.\n","id":"makeIndexableByNumber1()","line":"145"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"}],"kind":"method","comment":"\nExtract the state from [object] using an instanceMirror and the field\nnames in [fields]. Call the function [callback] on each value.\n","id":"extractState2()","line":"164"},{"name":"flatten","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","id":"flatten2()","line":"178"},{"name":"checkForEssentialLists","children":[{"name":"index","kind":"param","id":"index"},{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\nIf the value is a List, and the field is a constructor field or\notherwise specially designated, we wrap it in something that indicates\na restriction on the rules that can be used. Which in this case amounts\nto designating the rule, since we so far only have one rule per object.\n","id":"checkForEssentialLists2()","line":"198"},{"name":"_unwrap","children":[{"name":"result","kind":"param","id":"result"}],"isPrivate":true,"kind":"method","comment":"Remove any MapWrapper from the extracted state. ","id":"_unwrap1()","line":"208"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nCall the designated constructor with the appropriate fields from [state],\nfirst resolving references in the context of [reader].\n","id":"inflateEssential2()","line":"214"},{"name":"inflateNonEssential","children":[{"name":"rawState","kind":"param","id":"rawState"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"For all [state] not required in the constructor, set it in the [object],\nresolving references in the context of [reader].\n","id":"inflateNonEssential3()","line":"223"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nDetermine if this rule applies to the object in question. In our case\nthis is true if the type mirrors are the same.\n","id":"appliesTo2()","line":"237"},{"returnType":{"name":"void","refId":"void"},"name":"_findFields","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"constructorFields","kind":"param","id":"constructorFields"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"regularFields","kind":"param","id":"regularFields"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"excludeFields","kind":"param","id":"excludeFields","line":"244"}],"isPrivate":true,"kind":"method","comment":"\nGiven the various field lists provided by the user, construct the list\nof field names that we want.\n","id":"_findFields3()","line":"243"},{"name":"_value","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"name":"mirror","kind":"param","id":"mirror"},{"ref":{"name":"_Field","refId":"serialization/_Field"},"name":"field","kind":"param","id":"field"}],"isPrivate":true,"kind":"method","comment":"\nExtract the value of [field] from the object reflected\nby [mirror].\n","id":"_value2()","line":"267"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"constructorName","kind":"property","comment":"Return the name of the constructor used to create new instances on read.","id":"constructorName","line":"103"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"constructorFields","kind":"property","comment":"Return the list of field names to be passed to the constructor.","id":"constructorFields","line":"106"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"regularFields","kind":"property","comment":"Return the list of field names not used in the constructor. ","id":"regularFields","line":"109"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"hasVariableLengthEntries","kind":"property","id":"hasVariableLengthEntries","line":"253"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"dataLength","kind":"property","id":"dataLength","line":"255"},{"isFinal":true,"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"name":"type","kind":"variable","id":"type","line":"25"},{"ref":{"name":"Constructor","refId":"serialization/Constructor"},"name":"constructor","kind":"variable","id":"constructor","line":"28"},{"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"name":"fields","kind":"variable","id":"fields","line":"31"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"useMaps","kind":"variable","id":"useMaps","line":"38"},{"name":"BasicRule","children":[{"initializedField":{"name":"type","refId":"serialization/BasicRule/type"},"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"name":"type","kind":"param","id":"type"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"constructorName","kind":"param","id":"constructorName"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"constructorFields","kind":"param","id":"constructorFields","line":"62"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"regularFields","kind":"param","id":"regularFields","line":"62"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"excludeFields","kind":"param","id":"excludeFields","line":"63"}],"kind":"constructor","comment":"\nCreate this rule. Right now the user is obliged to pass a ClassMirror,\nbut once we allow class literals (Issue 6282) it will support that. The\nother parameters can all be left as null, and are optional on the\n[Serialization.addRule] method which is the normal caller for this.\n[constructorName] is the constructor, if not the default.\n[constructorFields] are the fields required to call the constructor, which\n  is the essential state. They don't have to be actual fields,\n  getter/setter pairs or getter/constructor pairs are fine. Note that\n  the constructorFields do not need to be strings, they can be arbitrary\n  values. For non-strings, these will be treated as constant values to be\n  used instead of data read from the objects.\n[regularFields] are the non-essential fields. They don't have to be actual\n  fields, getter/setter pairs are fine. If this is null, it's assumed\n  that we should figure them out.\n[excludeFields] lets you tell it to find the fields automatically, but\n  omit some that would otherwise be included.\n","id":"BasicRule5()","line":"61"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis is the basic rule for handling \"normal\" objects, which have a list of\nfields and a constructor, as opposed to simple types or collections. It uses\nmirrors to access the state, and can also use them to figure out the list\nof fields and the constructor if it's not provided.\n\nIf you call [Serialization.addRule], this is what you get.\n\n","id":"BasicRule","line":"20"},{"interfaces":[{"name":"List","refId":"dart.core/List"}],"superclass":{"name":"Iterable","refId":"dart.core/Iterable"},"name":"_LazyList","children":[{"isOperator":true,"name":"[]","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"[]1()","line":"511"},{"name":"indexOf","children":[{"name":"x","kind":"param","id":"x"},{"defaultValue":"0","isOptional":true,"name":"pos","kind":"param","id":"pos"}],"kind":"method","id":"indexOf2()","line":"523"},{"name":"lastIndexOf","children":[{"name":"x","kind":"param","id":"x"},{"isOptional":true,"name":"pos","kind":"param","id":"pos"}],"kind":"method","id":"lastIndexOf2()","line":"524"},{"name":"_throw","isPrivate":true,"kind":"method","id":"_throw0()","line":"527"},{"isOperator":true,"name":"[]=","children":[{"name":"x","kind":"param","id":"x"},{"name":"y","kind":"param","id":"y"}],"kind":"method","id":"[]=2()","line":"530"},{"name":"add","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"add1()","line":"531"},{"name":"addLast","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"addLast1()","line":"532"},{"name":"addAll","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"addAll1()","line":"533"},{"name":"sort","children":[{"isOptional":true,"name":"f","kind":"param","id":"f"}],"kind":"method","id":"sort1()","line":"534"},{"name":"clear","kind":"method","id":"clear0()","line":"535"},{"name":"removeAt","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"removeAt1()","line":"536"},{"name":"remove","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"remove1()","line":"537"},{"name":"removeLast","kind":"method","id":"removeLast0()","line":"538"},{"name":"removeAll","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"removeAll1()","line":"539"},{"name":"retainAll","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"retainAll1()","line":"540"},{"name":"removeMatching","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"removeMatching1()","line":"541"},{"name":"retainMatching","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"retainMatching1()","line":"542"},{"name":"getRange","children":[{"name":"x","kind":"param","id":"x"},{"name":"y","kind":"param","id":"y"}],"kind":"method","id":"getRange2()","line":"543"},{"name":"setRange","children":[{"name":"x","kind":"param","id":"x"},{"name":"y","kind":"param","id":"y"},{"name":"z","kind":"param","id":"z"},{"isOptional":true,"name":"a","kind":"param","id":"a"}],"kind":"method","id":"setRange4()","line":"544"},{"name":"removeRange","children":[{"name":"x","kind":"param","id":"x"},{"name":"y","kind":"param","id":"y"}],"kind":"method","id":"removeRange2()","line":"545"},{"name":"insertRange","children":[{"name":"x","kind":"param","id":"x"},{"name":"y","kind":"param","id":"y"},{"isOptional":true,"name":"z","kind":"param","id":"z"}],"kind":"method","id":"insertRange3()","line":"546"},{"isSetter":true,"returnType":{"name":"void","refId":"void"},"name":"length=","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"length=1()","line":"548"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"length","kind":"property","id":"length","line":"513"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"isEmpty","kind":"property","id":"isEmpty","line":"514"},{"name":"first","kind":"property","id":"first","line":"515"},{"name":"last","kind":"property","id":"last","line":"516"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"_inflated","isPrivate":true,"kind":"property","id":"_inflated","line":"521"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"iterator","kind":"property","id":"iterator","line":"522"},{"name":"reversed","kind":"property","id":"reversed","line":"547"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List"},"name":"_raw","isPrivate":true,"kind":"variable","id":"_raw","line":"507"},{"isFinal":true,"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"_reader","isPrivate":true,"kind":"variable","id":"_reader","line":"508"},{"name":"_LazyList","children":[{"initializedField":{"name":"_raw","refId":"serialization/_LazyList/_raw"},"ref":{"name":"List","refId":"dart.core/List"},"name":"_raw","isPrivate":true,"kind":"param","id":"_raw"},{"initializedField":{"name":"_reader","refId":"serialization/_LazyList/_reader"},"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"_reader","isPrivate":true,"kind":"param","id":"_reader"}],"kind":"constructor","id":"_LazyList2()","line":"505"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis provides an implementation of List that wraps a list which may\ncontain references to (potentially) non-inflated objects. If these\nare accessed it will inflate them. This allows us to pass something that\nlooks like it's just a list of objects to a [CustomRule] without needing\nto inflate all the references in advance.\n","id":"_LazyList","line":"504"},{"interfaces":[{"name":"Map","refId":"dart.core/Map"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"_LazyMap","children":[{"isOperator":true,"name":"[]","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"[]1()","line":"473"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"containsKey","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"containsKey1()","line":"478"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"containsValue","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"containsValue1()","line":"483"},{"returnType":{"name":"void","refId":"void"},"name":"forEach","children":[{"name":"f","kind":"param","id":"f"}],"kind":"method","id":"forEach1()","line":"485"},{"name":"_throw","isPrivate":true,"kind":"method","id":"_throw0()","line":"488"},{"isOperator":true,"name":"[]=","children":[{"name":"x","kind":"param","id":"x"},{"name":"y","kind":"param","id":"y"}],"kind":"method","id":"[]=2()","line":"491"},{"name":"putIfAbsent","children":[{"name":"x","kind":"param","id":"x"},{"name":"y","kind":"param","id":"y"}],"kind":"method","id":"putIfAbsent2()","line":"492"},{"name":"remove","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","id":"remove1()","line":"493"},{"name":"clear","kind":"method","id":"clear0()","line":"494"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"length","kind":"property","id":"length","line":"475"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"isEmpty","kind":"property","id":"isEmpty","line":"476"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable"},"name":"keys","kind":"property","id":"keys","line":"477"},{"name":"_inflated","isPrivate":true,"kind":"property","id":"_inflated","line":"482"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable"},"name":"values","kind":"property","id":"values","line":"484"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map"},"name":"_raw","isPrivate":true,"kind":"variable","id":"_raw","line":"469"},{"isFinal":true,"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"_reader","isPrivate":true,"kind":"variable","id":"_reader","line":"470"},{"name":"_LazyMap","children":[{"initializedField":{"name":"_raw","refId":"serialization/_LazyMap/_raw"},"ref":{"name":"Map","refId":"dart.core/Map"},"name":"_raw","isPrivate":true,"kind":"param","id":"_raw"},{"initializedField":{"name":"_reader","refId":"serialization/_LazyMap/_reader"},"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"_reader","isPrivate":true,"kind":"param","id":"_reader"}],"kind":"constructor","id":"_LazyMap2()","line":"467"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis provides an implementation of Map that wraps a list which may\ncontain references to (potentially) non-inflated objects. If these\nare accessed it will inflate them. This allows us to pass something that\nlooks like it's just a list of objects to a [CustomRule] without needing\nto inflate all the references in advance.\n","id":"_LazyMap","line":"466"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"isAbstract":true,"name":"CustomRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"instance","kind":"param","id":"instance"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","id":"appliesTo2()","line":"408"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"getState","children":[{"name":"instance","kind":"param","id":"instance"}],"kind":"method","comment":"\nSubclasses should implement this to return a list of the important fields\nin the object. The order of the fields doesn't matter, except that the\ncreate and setState methods need to know how to use it.\n","id":"getState1()","line":"415"},{"name":"create","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"\nGiven a [List] of the object's [state], re-create the object. This should\ndo the minimum needed to create the object, just calling the constructor.\nSetting the remaining state of the object should be done in the [setState]\nmethod, which will be called only once all the objects are created, so\nit won't cause problems with cycles.\n","id":"create1()","line":"424"},{"returnType":{"name":"void","refId":"void"},"name":"setState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"\nSet any state in [object] which wasn't set in the constructor. Between\nthis method and [create] all of the information in [state] should be set\nin the new object.\n","id":"setState2()","line":"431"},{"name":"extractState","children":[{"name":"instance","kind":"param","id":"instance"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","id":"extractState2()","line":"433"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateEssential2()","line":"441"},{"returnType":{"name":"void","refId":"void"},"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssential3()","line":"443"},{"name":"hasVariableLengthEntries","kind":"property","id":"hasVariableLengthEntries","line":"449"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis provides an abstract superclass for writing your own rules specific to\na class. It makes some assumptions about behaviour, and so can have a\nsimpler set of methods that need to be implemented in order to subclass it.\n\n","id":"CustomRule","line":"398"},{"superclass":{"name":"NamedObjectRule","refId":"serialization/NamedObjectRule"},"name":"MirrorRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","id":"appliesTo2()","line":"388"},{"name":"nameFor","children":[{"ref":{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"},"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","id":"nameFor2()","line":"389"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles the special case of Mirrors, restricted to those that\nhave a simpleName. It knows that it applies to any such mirror and\nautomatically uses its simpleName as the key into the namedObjects.\nWhen reading, the user is still responsible for adding the appropriate\nmirrors to namedObject.\n","id":"MirrorRule","line":"387"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"NamedObjectRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nReturn true if this rule applies to the object. Checked by looking up\nin the namedObjects collection.\n","id":"appliesTo2()","line":"353"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","comment":"Extract the state of the named objects as just the object itself. ","id":"extractState2()","line":"358"},{"name":"flatten","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"When we flatten the state we save it as the name. ","id":"flatten2()","line":"366"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"Look up the named object and return it. ","id":"inflateEssential2()","line":"371"},{"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"Set any non-essential state on the object. For this rule, a no-op. ","id":"inflateNonEssential3()","line":"374"},{"name":"nameFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"Return the name for this object in the Writer. ","id":"nameFor2()","line":"377"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things we can't pass directly, but only by reference.\nIf objects are listed in the namedObjects in the writer or serialization,\nit will save the name rather than saving the state.\n","id":"NamedObjectRule","line":"348"},{"superclass":{"name":"CustomRule","refId":"serialization/CustomRule"},"name":"ClosureRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","id":"appliesTo2()","line":"331"},{"name":"getState","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","id":"getState1()","line":"333"},{"name":"create","children":[{"name":"state","kind":"param","id":"state"}],"kind":"method","id":"create1()","line":"335"},{"name":"setState","children":[{"name":"object","kind":"param","id":"object"},{"name":"state","kind":"param","id":"state"}],"kind":"method","id":"setState2()","line":"337"},{"isFinal":true,"ref":{"name":"Type","refId":"dart.core/Type"},"name":"type","kind":"variable","id":"type","line":"312"},{"ref":{"name":"ConstructType","refId":"serialization/ConstructType"},"name":"construct","kind":"variable","id":"construct","line":"315"},{"ref":{"name":"GetStateType","refId":"serialization/GetStateType"},"name":"getStateFunction","kind":"variable","id":"getStateFunction","line":"318"},{"ref":{"name":"NonEssentialStateType","refId":"serialization/NonEssentialStateType"},"name":"setNonEssentialState","kind":"variable","id":"setNonEssentialState","line":"321"},{"name":"ClosureRule","children":[{"initializedField":{"name":"type","refId":"serialization/ClosureRule/type"},"ref":{"name":"Type","refId":"dart.core/Type"},"name":"type","kind":"param","id":"type"},{"initializedField":{"name":"getStateFunction","refId":"serialization/ClosureRule/getStateFunction"},"ref":{"name":"GetStateType","refId":"serialization/GetStateType"},"name":"getStateFunction","kind":"param","id":"getStateFunction"},{"initializedField":{"name":"construct","refId":"serialization/ClosureRule/construct"},"ref":{"name":"ConstructType","refId":"serialization/ConstructType"},"name":"construct","kind":"param","id":"construct"},{"initializedField":{"name":"setNonEssentialState","refId":"serialization/ClosureRule/setNonEssentialState"},"ref":{"name":"NonEssentialStateType","refId":"serialization/NonEssentialStateType"},"name":"setNonEssentialState","kind":"param","id":"setNonEssentialState","line":"329"}],"kind":"constructor","comment":"\nCreate a ClosureToMapRule for the given [type] which gets an object's\nstate by calling [getState], creates a new object by calling [construct]\nand sets the new object's state by calling [setNonEssentialState].\n","id":"ClosureRule4()","line":"328"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis is a rule where the extraction and creation are hard-coded as\nclosures. The result is expected to be a map indexed by field name.\n","id":"ClosureRule","line":"309"},{"returnType":{"name":"void","refId":"void"},"name":"NonEssentialStateType","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"m","kind":"param","id":"m"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the state-setting closure used in ClosureToMapRule. ","id":"NonEssentialStateType","line":"303"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"GetStateType","children":[{"name":"object","kind":"param","id":"object"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the state-getting closure used in ClosureToMapRule. ","id":"GetStateType","line":"300"},{"name":"ConstructType","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"m","kind":"param","id":"m"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the object construction closure used in ClosureRule. ","id":"ConstructType","line":"297"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"PrimitiveRule","children":[{"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","id":"appliesTo2()","line":"275"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","id":"extractState2()","line":"278"},{"name":"flatten","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","id":"flatten2()","line":"279"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateEssential2()","line":"280"},{"name":"inflateNonEssential","children":[{"name":"object","kind":"param","id":"object"},{"name":"_","isPrivate":true,"kind":"param","id":"_"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssential3()","line":"281"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferenceFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nIndicate whether we should save pointers to this object as references\nor store the object directly. For primitives this depends on the format,\nso we delegate to the writer.\n","id":"shouldUseReferenceFor2()","line":"290"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"storesStateAsPrimitives","kind":"property","id":"storesStateAsPrimitives","line":"283"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"hasVariableLengthEntries","kind":"property","id":"hasVariableLengthEntries","line":"293"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles primitive types, defined as those that we can normally\nrepresent directly in the output format. We hard-code that to mean\nnum, String, and bool.\n","id":"PrimitiveRule","line":"274"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"MapRule","children":[{"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","id":"appliesTo2()","line":"199"},{"name":"extractState","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"map","kind":"param","id":"map"},{"name":"f","kind":"param","id":"f"}],"kind":"method","id":"extractState2()","line":"203"},{"name":"flatten","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nChange the keys and values of [state] into references in [writer].\nIf [state] is a map whose keys are all strings then we leave the keys\nas is so that JSON formats will be more readable. If the keys are\narbitrary then we need to turn them into references and replace the\nstate with a new Map whose keys are the references.\n","id":"flatten2()","line":"220"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateEssential2()","line":"236"},{"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"newMap","kind":"param","id":"newMap"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssential3()","line":"240"},{"returnType":{"name":"void","refId":"void"},"name":"inflateNonEssentialFromList","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"newMap","kind":"param","id":"newMap"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssentialFromList3()","line":"248"},{"returnType":{"name":"void","refId":"void"},"name":"inflateNonEssentialFromMap","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"newMap","kind":"param","id":"newMap"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssentialFromMap3()","line":"260"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"storesStateAsMaps","kind":"property","id":"storesStateAsMaps","line":"201"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"hasVariableLengthEntries","kind":"property","id":"hasVariableLengthEntries","line":"266"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things that implement Map. It will recreate them as\nwhatever the default implemenation of Map is on the target platform. If a\nmap has string keys it will attempt to retain it as a map for JSON formats,\notherwise it will store it as a list of references to keys and values.\n","id":"MapRule","line":"197"},{"superclass":{"name":"ListRule","refId":"serialization/ListRule"},"name":"ListRuleEssential","children":[{"name":"inflateEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"Create the new List and also inflate all of its contents. ","id":"inflateEssential2()","line":"179"},{"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"newList","kind":"param","id":"newList"},{"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"Does nothing, because all the work has been done in inflateEssential. ","id":"inflateNonEssential3()","line":"186"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"mustBePrimary","kind":"property","id":"mustBePrimary","line":"188"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis is a subclass of ListRule where all of the list's contents are\nconsidered essential state. This is needed if an object X contains a List L,\nbut it expects L's contents to be fixed when X's constructor is called.\n","id":"ListRuleEssential","line":"176"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"ListRule","children":[{"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","id":"appliesTo2()","line":"141"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"extractState","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"list","kind":"param","id":"list"},{"name":"f","kind":"param","id":"f"}],"kind":"method","id":"extractState2()","line":"145"},{"name":"inflateEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateEssential2()","line":"154"},{"name":"inflateNonEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"newList","kind":"param","id":"newList"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssential3()","line":"158"},{"returnType":{"name":"void","refId":"void"},"name":"populateContents","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"newList","kind":"param","id":"newList"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"populateContents3()","line":"162"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"storesStateAsLists","kind":"property","id":"storesStateAsLists","line":"143"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"hasVariableLengthEntries","kind":"property","id":"hasVariableLengthEntries","line":"168"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things that implement List. It will recreate them as\nwhatever the default implemenation of List is on the target platform.\n","id":"ListRule","line":"139"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"SerializationRule","children":[{"isSetter":true,"returnType":{"name":"void","refId":"void"},"name":"number=","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","id":"number=1()","line":"30"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","id":"appliesTo2()","line":"40"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","children":[{"returnType":{"name":"void","refId":"void"},"name":"Function","children":[{"name":"value","uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"param","id":"value","line":"48"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","id":"Function","line":"13"}],"kind":"param","id":"f"}],"kind":"method","comment":"\nThis extracts the state from the object, calling [f] for each value\nas it is extracted, and returning an object representing the whole\nstate at the end. The state that results will still have direct\npointers to objects, rather than references.\n","id":"extractState2()","line":"48"},{"name":"flatten","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nGiven the variables representing the state of an object, flatten it\nby turning object pointers into Reference objects where needed. This\ndestructively modifies the state object.\n\nThis has a default implementation which assumes that object is indexable,\nso either conforms to Map or List. Subclasses may override to do something\ndifferent, including returning a new state object to be used in place\nof the original.\n","id":"flatten2()","line":"73"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nCreate the new object corresponding to [state] using the rules\nfrom [reader]. This may involve recursively inflating \"essential\"\nreferences in the state, which are those that are required for the\nobject's constructor. It is up to the rule what state is considered\nessential.\n","id":"inflateEssential2()","line":"103"},{"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nThe [object] has already been created. Set any of its non-essential\nvariables from the representation in [state]. Where there are references\nto other objects they are resolved in the context of [reader].\n","id":"inflateNonEssential3()","line":"110"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferenceFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nIf we have [object] as part of our state, should we represent that\ndirectly, or should we make a reference for it. By default, true.\nThis may also delegate to [writer].\n","id":"shouldUseReferenceFor2()","line":"117"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"number","kind":"property","comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","id":"number","line":"24"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"storesStateAsLists","kind":"property","comment":"\nAllows rules to tell us how they expect to store their state. If this\nisn't specified we can also just look at the data to tell.\n","id":"storesStateAsLists","line":"54"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"storesStateAsMaps","kind":"property","id":"storesStateAsMaps","line":"55"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"storesStateAsPrimitives","kind":"property","id":"storesStateAsPrimitives","line":"56"},{"name":"mustBePrimary","kind":"property","comment":"Return true if this rule should only be applied when we are the first\nrule found that applies to this object. This may or may not be a hack\nthat will disappear once we have better support for multiple rules.\nWe want to have multiple different rules that apply to the same object. We\nalso want to have multiple different rules that might exclusively apply\nto the same object. So, we want either ListRule or ListRuleEssential, and\nonly one of them can be there. But on the other hand, we may want both\nListRule and BasicRule. So we identify the kinds of rules that can share.\nIf mustBePrimary returns true, then this rule will only be chosen if no\nother rule has been found yet. This means that the ordering of rules in\nthe serialization is significant, which is unpleasant, but we'll have\nto see how bad it is.\n","id":"mustBePrimary","line":"94"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"hasVariableLengthEntries","kind":"property","comment":"\nReturn true if the data this rule returns is variable length, so a\nlength needs to be written for it if the format requires that. Return\nfalse if the results are always the same length.\n","id":"hasVariableLengthEntries","line":"124"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"dataLength","kind":"property","comment":"\nIf the data is fixed length, return it here. The format may or may not\nmake use of this, depending on whether it already has enough information\nto determine the length on its own. If [hasVariableLengthEntries] is true\nthis is ignored.\n","id":"dataLength","line":"132"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"_number","isPrivate":true,"kind":"variable","id":"_number","line":"18"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThe abstract superclass for serialization rules.\n","id":"SerializationRule","line":"13"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"DesignatedRuleForObject","children":[{"name":"possibleRules","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"rules","kind":"param","id":"rules"}],"kind":"method","id":"possibleRules1()","line":"608"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"rulePredicate","kind":"variable","id":"rulePredicate","line":"603"},{"isFinal":true,"name":"target","kind":"variable","id":"target","line":"604"},{"name":"DesignatedRuleForObject","children":[{"initializedField":{"name":"target","refId":"serialization/DesignatedRuleForObject/target"},"name":"target","kind":"param","id":"target"},{"initializedField":{"name":"rulePredicate","refId":"serialization/DesignatedRuleForObject/rulePredicate"},"ref":{"name":"Function","refId":"dart.core/Function"},"name":"rulePredicate","kind":"param","id":"rulePredicate"}],"kind":"constructor","id":"DesignatedRuleForObject2()","line":"606"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis is used during tracing to indicate that an object should be processed\nusing a particular rule, rather than the one that might ordinarily be\nfound for it. This normally only makes sense if the object is uniquely\nreferenced, and is a more or less internal collection. See ListRuleEssential\nfor an example. It knows how to return its object and how to filter.\n","id":"DesignatedRuleForObject","line":"602"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Reference","children":[{"name":"inflated","kind":"method","comment":"\nReturn the thing this reference points to. Assumes that we have a valid\nparent and that it is a Reader, as inflating is not meaningful when\nwriting.\n","id":"inflated0()","line":"571"},{"name":"toJson","kind":"method","comment":"\nConvert the reference to a map in JSON format. This is specific to the\ncustom JSON format we define, and must be consistent with the\n[asReference] method.\n","id":"toJson0()","line":"580"},{"name":"writeToList","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"list","kind":"param","id":"list"}],"kind":"method","comment":"Write our information to [list]. Useful in writing to flat formats.","id":"writeToList1()","line":"587"},{"name":"toString","kind":"method","id":"toString0()","line":"592"},{"isFinal":true,"ref":{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"},"name":"parent","kind":"variable","id":"parent","line":"551"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"name":"ruleNumber","kind":"variable","id":"ruleNumber","line":"553"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"name":"objectNumber","kind":"variable","id":"objectNumber","line":"555"},{"name":"Reference","children":[{"initializedField":{"name":"parent","refId":"serialization/Reference/parent"},"ref":{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"},"name":"parent","kind":"param","id":"parent"},{"initializedField":{"name":"ruleNumber","refId":"serialization/Reference/ruleNumber"},"ref":{"name":"int","refId":"dart.core/int"},"name":"ruleNumber","kind":"param","id":"ruleNumber"},{"initializedField":{"name":"objectNumber","refId":"serialization/Reference/objectNumber"},"ref":{"name":"int","refId":"dart.core/int"},"name":"objectNumber","kind":"param","id":"objectNumber"}],"kind":"constructor","id":"Reference3()","line":"557"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nAny pointers to objects that can't be represented directly in the\nserialization format has to be stored as a reference. A reference encodes\nthe rule number of the rule that saved it in the Serialization that was used\nfor writing, and the object number within that rule.\n","id":"Reference","line":"549"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Trace","children":[{"name":"addRoot","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","id":"addRoot1()","line":"504"},{"name":"trace","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"A convenience method to add a single root and trace it in one step. ","id":"trace1()","line":"509"},{"name":"traceAll","kind":"method","comment":"\nProcess all of the objects reachable from our roots via state that the\nserialization rules access.\n","id":"traceAll0()","line":"518"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"hasProcessed","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nHas this object been seen yet? We test for this by checking if the\nwriter has a reference for it. See comment for _hasIndexFor.\n","id":"hasProcessed1()","line":"530"},{"name":"note","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Note that we've seen [value], and add it to the queue to be processed. ","id":"note1()","line":"535"},{"isFinal":true,"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"variable","id":"writer","line":"491"},{"isFinal":true,"ref":{"name":"Queue","refId":"dart.collection/Queue"},"name":"queue","kind":"variable","id":"queue","line":"497"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"roots","kind":"variable","id":"roots","line":"500"},{"name":"Trace","children":[{"initializedField":{"name":"writer","refId":"serialization/Trace/writer"},"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"constructor","id":"Trace1()","line":"502"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis represents the transitive closure of the referenced objects to be\nused for serialization. It works closely in conjunction with the Writer,\nand is kept as a separate object primarily for the possibility of wanting\nto plug in different sorts of tracing rules.\n","id":"Trace","line":"487"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"_Sentinel","children":[{"name":"_Sentinel","kind":"constructor","id":"_Sentinel0()","line":"478"}],"isPrivate":true,"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis serves as a marker to indicate a object that is in the process of\nbeing de-serialized. So if we look for an object slot and find one of these,\nwe know we've hit a cycle.\n","id":"_Sentinel","line":"477"},{"interfaces":[{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Reader","children":[{"name":"objectNamed","children":[{"name":"key","kind":"param","id":"key"}],"kind":"method","comment":"\nLook up the reference to an external object. This can be held either in\nthe reader-specific list of externals or in the serializer's\n","id":"objectNamed1()","line":"312"},{"isSetter":true,"returnType":{"name":"void","refId":"void"},"name":"data=","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"newData","kind":"param","id":"newData"}],"kind":"method","comment":"\nInternal use only, for testing purposes. Set the data for this reader\nto a List of Lists whose size must match the number of rules.\n","id":"data=1()","line":"332"},{"name":"read","children":[{"name":"rawInput","kind":"param","id":"rawInput"},{"ref":{"name":"Map","refId":"dart.core/Map"},"defaultValue":"const{}","isOptional":true,"name":"externals","kind":"param","id":"externals"}],"kind":"method","comment":"\nThis is the primary method for a [Reader]. It takes the input data,\ndecodes it according to [format] and returns the root object.\n","id":"read2()","line":"341"},{"returnType":{"name":"void","refId":"void"},"name":"readRules","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"newRules","kind":"param","id":"newRules"}],"kind":"method","comment":"\nIf the data we are reading from has rules written to it, read them back\nand set them as the rules we will use.\n","id":"readRules1()","line":"353"},{"name":"inflateForRule","children":[{"name":"rule","kind":"param","id":"rule"}],"kind":"method","comment":"\nInflate all of the objects for [rule]. Does the essential state for all\nobjects first, then the non-essential state. This avoids cycles in\nnon-essential state, because all the objects will have already been\ncreated.\n","id":"inflateForRule1()","line":"369"},{"name":"inflateOne","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"name":"position","kind":"param","id":"position"},{"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"\nCreate a new object, based on [rule] and [state], which will\nbe stored in [position] in the storage for [rule]. This will\nfollow references and recursively inflate them, leaving Sentinel objects\nto detect cycles.\n","id":"inflateOne3()","line":"385"},{"name":"inflateReference","children":[{"name":"possibleReference","kind":"param","id":"possibleReference"}],"kind":"method","comment":"\nThe parameter [possibleReference] might be a reference. If it isn't, just\nreturn it. If it is, then inflate the target of the reference and return\nthe resulting object.\n","id":"inflateReference1()","line":"406"},{"name":"resolveReference","children":[{"name":"reference","kind":"param","id":"reference"}],"kind":"method","comment":"Return the object pointed to by [reference]. ","id":"resolveReference1()","line":"419"},{"name":"_objectFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"reference","kind":"param","id":"reference"}],"isPrivate":true,"kind":"method","comment":"\nGiven [reference], return what we have stored as an object for it. Note\nthat, depending on the current state, this might be null or a Sentinel.\n","id":"_objectFor1()","line":"425"},{"name":"allObjectsForRule","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"kind":"method","comment":"Given [rule], return the storage for its objects. ","id":"allObjectsForRule1()","line":"429"},{"name":"_stateFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"reference","kind":"param","id":"reference"}],"isPrivate":true,"kind":"method","comment":"Given [reference], return the the state we have stored for it. ","id":"_stateFor1()","line":"432"},{"returnType":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"ruleFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"reference","kind":"param","id":"reference"}],"kind":"method","comment":"Given a reference, return the rule it references. ","id":"ruleFor1()","line":"436"},{"returnType":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"_primitiveRule","isPrivate":true,"kind":"method","comment":"\nReturn the primitive rule we are using. This is an ugly mechanism to\nsupport the extra information to reconstruct objects in the\n[SimpleJsonFormat].\n","id":"_primitiveRule0()","line":"444"},{"name":"asReference","children":[{"name":"anObject","kind":"param","id":"anObject"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"defaultValue":"doNothing","isOptional":true,"name":"ifReference","kind":"param","id":"ifReference"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"defaultValue":"doNothing","isOptional":true,"name":"ifNotReference","kind":"param","id":"ifNotReference","line":"460"}],"kind":"method","comment":"\nGiven a possible reference [anObject], call either [ifReference] or\n[ifNotReference], depending if it's a reference or not. This is the\nprimary place that knows about the serialized representation of a\nreference.\n","id":"asReference3()","line":"459"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"name":"rules","kind":"property","comment":"\nReturn the list of rules to be used when writing. These come from the\n[serialization].\n","id":"rules","line":"325"},{"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"variable","id":"serialization","line":"261"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"selfDescribing","kind":"variable","id":"selfDescribing","line":"267"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"_data","isPrivate":true,"kind":"variable","id":"_data","line":"277"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"objects","kind":"variable","id":"objects","line":"284"},{"ref":{"name":"Format","refId":"serialization/Format"},"name":"format","kind":"variable","id":"format","line":"286"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"namedObjects","kind":"variable","id":"namedObjects","line":"306"},{"name":"Reader","children":[{"initializedField":{"name":"serialization","refId":"serialization/Reader/serialization"},"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"param","id":"serialization"},{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"name":"newFormat","kind":"param","id":"newFormat"}],"kind":"constructor","comment":"\nCreates a new [Reader] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state related to\na particular read or write operation, so the same one can be used\nfor multiple different Writers/Readers.\n","id":"Reader2()","line":"294"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThe main class responsible for reading. It holds\nonto the necessary state and to the objects that have been inflated.\n","id":"Reader","line":"253"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"ReaderOrWriter","children":[{"name":"resolveReference","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"ref","kind":"param","id":"ref"}],"kind":"method","comment":"\nReturn the object, or state, that ref points to, depending on which\nwe're generating.\n","id":"resolveReference1()","line":"246"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"name":"rules","kind":"property","comment":"Return the list of serialization rules we are using.","id":"rules","line":"240"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nAn abstract class for Reader and Writer, which primarily exists so we can\ntype things that will refer to one or the other, depending on which\noperation we're doing.\n","id":"ReaderOrWriter","line":"238"},{"interfaces":[{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Writer","children":[{"name":"write","children":[{"name":"anObject","kind":"param","id":"anObject"}],"kind":"method","comment":"\nThis is the main API for a [Writer]. It writes the objects and returns\nthe serialized representation, as determined by [format].\n","id":"write1()","line":"74"},{"returnType":{"name":"void","refId":"void"},"name":"_flatten","isPrivate":true,"kind":"method","comment":"\nGiven that we have fully populated the list of [states], and more\nimportantly, the list of [references], go through each state and turn\nanything that requires a [Reference] into one. Since only the rules\nknow the representation they use for state, delegate to them.\n","id":"_flatten0()","line":"87"},{"returnType":{"name":"void","refId":"void"},"name":"_process","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Trace","refId":"serialization/Trace"},"name":"trace","kind":"param","id":"trace"}],"isPrivate":true,"kind":"method","comment":"\nAs the [trace] processes each object, it will call this method on us.\nWe find the rules for this object, and record the state of the object\nas determined by each rule.\n","id":"_process2()","line":"107"},{"returnType":{"name":"void","refId":"void"},"name":"_record","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"isPrivate":true,"kind":"method","comment":"\nRecord the state of [object] as determined by [rule] and keep\ntrack of it. Generate a [Reference] for this object if required.\nWhen it's required is up to the particular rule, but generally everything\ngets a reference except a primitive.\nNote that at this point the states are just the same as the fields of the\nobject, and haven't been flattened.\n","id":"_record2()","line":"122"},{"name":"serializedRules","kind":"method","comment":"\nReturns a serialized version of the [SerializationRule]s used to write\nthe data, if [selfDescribing] is true, otherwise returns null.\n","id":"serializedRules0()","line":"143"},{"returnType":{"name":"void","refId":"void"},"name":"_addStateForRule","children":[{"name":"eachRule","kind":"param","id":"eachRule"},{"name":"state","kind":"param","id":"state"}],"isPrivate":true,"kind":"method","comment":"Record a [state] entry for a particular rule. ","id":"_addStateForRule2()","line":"152"},{"returnType":{"name":"int","refId":"dart.core/int"},"name":"_nextObjectNumberFor","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"isPrivate":true,"kind":"method","comment":"Find what the object number for the thing we're about to add will be.","id":"_nextObjectNumberFor1()","line":"158"},{"returnType":{"name":"void","refId":"void"},"name":"_growStates","children":[{"name":"eachRule","kind":"param","id":"eachRule"}],"isPrivate":true,"kind":"method","comment":"\nWe store the states in a List, indexed by rule number. But rules can be\ndynamically added, so we may have to grow the list.\n","id":"_growStates1()","line":"167"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"_hasIndexFor","children":[{"name":"object","kind":"param","id":"object"}],"isPrivate":true,"kind":"method","comment":"\nReturn true if we have an object number for this object. This is used to\ntell if we have processed the object or not. This relies on checking if we\nhave a reference or not. That saves some space by not having to keep track\nof simple objects, but means that if someone refers to the identical string\nfrom several places, we will process it several times, and store it\nseveral times. That seems an acceptable tradeoff, and in cases where it\nisn't, it's possible to apply a rule for String, or even for Strings larger\nthan x, which gives them references.\n","id":"_hasIndexFor1()","line":"181"},{"returnType":{"name":"int","refId":"dart.core/int"},"name":"_objectNumberFor","children":[{"name":"object","kind":"param","id":"object"}],"isPrivate":true,"kind":"method","comment":"\nGiven an object, find what number it has. The number is valid only in\nthe context of a particular rule, and if the rule has more than one,\nthis will return the one for the primary rule, defined as the one that\nis listed in its canonical reference.\n","id":"_objectNumberFor1()","line":"191"},{"name":"_rootReferences","isPrivate":true,"kind":"method","comment":"\nReturn a list of [Reference] objects pointing to our roots. This will be\nstored in the output under \"roots\" in the default format.\n","id":"_rootReferences0()","line":"200"},{"name":"_referenceFor","children":[{"name":"object","kind":"param","id":"object"}],"isPrivate":true,"kind":"method","comment":"\nGiven an object, return a reference for it if one exists. If there's\nno reference, return the object itself. Once we have finished the tracing\nstep, all objects that should have a reference (roughly speaking,\nnon-primitives) can be relied on to have a reference.\n","id":"_referenceFor1()","line":"208"},{"name":"hasNameFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nReturn true if the [namedObjects] collection has a reference to [object].\n","id":"hasNameFor1()","line":"219"},{"name":"nameFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nReturn the name we have for this object in the [namedObjects] collection.\n","id":"nameFor1()","line":"224"},{"name":"stateForReference","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"stateForReference1()","line":"227"},{"name":"resolveReference","children":[{"name":"reference","kind":"param","id":"reference"}],"kind":"method","comment":"Return the state pointed to by [reference]. ","id":"resolveReference1()","line":"230"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"name":"rules","kind":"property","comment":"Return the list of rules we use. ","id":"rules","line":"56"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferencesForPrimitives","kind":"property","comment":"\nShould we store primitive objects directly or create references for them.\nThat depends on which format we're using, so a flat format will want\nreferences, but the Map format can store them directly.\n","id":"shouldUseReferencesForPrimitives","line":"136"},{"isFinal":true,"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"variable","id":"serialization","line":"21"},{"ref":{"name":"Trace","refId":"serialization/Trace"},"name":"trace","kind":"variable","id":"trace","line":"25"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"selfDescribing","kind":"variable","id":"selfDescribing","line":"32"},{"ref":{"name":"Format","refId":"serialization/Format"},"name":"format","kind":"variable","id":"format","line":"34"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Reference","refId":"serialization/Reference"}]},"name":"references","kind":"variable","id":"references","line":"42"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"states","kind":"variable","id":"states","line":"53"},{"name":"Writer","children":[{"initializedField":{"name":"serialization","refId":"serialization/Writer/serialization"},"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"param","id":"serialization"},{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"name":"newFormat","kind":"param","id":"newFormat"}],"kind":"constructor","comment":"\nCreates a new [Writer] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state\nrelated to a particular read/write, so the same one can be used\nfor multiple different Readers/Writers.\n","id":"Writer2()","line":"64"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis writes out the state of the objects to an external format. It holds\nall of the intermediate state needed. The primary API for it is the\n[write] method.\n","id":"Writer","line":"16"},{"interfaces":[{"name":"Exception","refId":"dart.core/Exception"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isThrowable":true,"name":"SerializationException","children":[{"name":"toString","kind":"method","id":"toString0()","line":"468"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"variable","id":"message","line":"466"},{"name":"SerializationException","children":[{"initializedField":{"name":"message","refId":"serialization/SerializationException/message"},"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"name":"message","kind":"param","id":"message"}],"kind":"constructor","id":"SerializationException1()","line":"467"}],"kind":"class","comment":"\nAn exception class for errors during serialization.\n","id":"SerializationException","line":"465"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Serialization","children":[{"isSetter":true,"name":"selfDescribing=","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","id":"selfDescribing=1()","line":"248"},{"returnType":{"name":"BasicRule","refId":"serialization/BasicRule"},"name":"addRuleFor","children":[{"name":"instanceOfType","kind":"param","id":"instanceOfType","line":"292"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"name":"constructor","kind":"param","id":"constructor","line":"293"},{"ref":{"name":"List","refId":"dart.core/List"},"isNamed":true,"isOptional":true,"name":"constructorFields","kind":"param","id":"constructorFields","line":"294"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"isNamed":true,"isOptional":true,"name":"fields","kind":"param","id":"fields","line":"295"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"isNamed":true,"isOptional":true,"name":"excludeFields","kind":"param","id":"excludeFields","line":"296"}],"kind":"method","comment":"\nCreate a [BasicRule] rule for the type of\n[instanceOfType]. Optionally\nallows specifying a [constructor] name, the list of [constructorFields],\nand the list of [fields] not used in the constructor. Returns the new\nrule. Note that [BasicRule] uses reflection, and so will not work with the\ncurrent state of dartj2s. If you need to run there, consider using\n[CustomRule] instead.\n\nIf the optional parameters aren't specified, the default constructor will\nbe used, and the list of fields will be computed. Alternatively, you can\nomit [fields] and provide [excludeFields], which will then compute the\nlist of fields specifically excluding those listed.\n\nThe fields can be actual public fields, but can also be getter/setter\npairs or getters whose value is provided in the constructor. For the\n[constructorFields] they can also be arbitrary objects. Anything that is\nnot a String will be treated as a constant value to be used in any\nconstruction of these objects.\n\nIf the list of fields is computed, fields from the superclass will be\nincluded. However, each subclass needs its own rule, since the constructors\nare not inherited, and so may need to be specified separately for each\nsubclass.\n","id":"addRuleFor5()","line":"291"},{"returnType":{"name":"void","refId":"void"},"name":"addDefaultRules","kind":"method","comment":"Set up the default rules, for lists and primitives. ","id":"addDefaultRules0()","line":"308"},{"returnType":{"name":"void","refId":"void"},"name":"addRule","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"kind":"method","comment":"\nAdd a new SerializationRule [rule]. The addRuleFor method will probably\nhandle most simple cases, but for adding an arbitrary rule, including\na SerializationRule subclass which you have created, you can use this\nmethod.\n","id":"addRule1()","line":"323"},{"name":"write","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"name":"object","kind":"param","id":"object"},{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"name":"format","kind":"param","id":"format"}],"kind":"method","comment":"\nThis writes out an object graph rooted at [object] and returns the result.\nThe [format] parameter determines the form of the result. The default\nformat returns a String in [json] format.\n","id":"write2()","line":"333"},{"returnType":{"name":"Writer","refId":"serialization/Writer"},"name":"newWriter","children":[{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"name":"format","kind":"param","id":"format"}],"kind":"method","comment":"\nReturn a new [Writer] object for this serialization. This is useful if you\nwant to do something more complex with the writer than just returning\nthe final result.\n","id":"newWriter1()","line":"342"},{"name":"read","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"Map","refId":"dart.core/Map"},"defaultValue":"const{}","isOptional":true,"name":"externals","kind":"param","id":"externals"}],"kind":"method","comment":"\nRead the serialized data from [input] and return the root object\nfrom the result. If there are objects that need to be resolved\nin the current context, they should be provided in [externals] as a\nMap from names to values. In particular, in the current implementation\nany class mirrors needed should be provided in [externals] using the\nclass name as a key. In addition to the [externals] map provided here,\nvalues will be looked up in the [externalObjects] map.\n","id":"read2()","line":"354"},{"returnType":{"name":"Reader","refId":"serialization/Reader"},"name":"newReader","children":[{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"name":"format","kind":"param","id":"format"}],"kind":"method","comment":"\nReturn a new [Reader] object for this serialization. This is useful if\nyou want to do something more complex with the reader than just returning\nthe final result.\n","id":"newReader1()","line":"363"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"name":"rulesFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nReturn the list of SerializationRule that apply to [object]. For\ninternal use, but public because it's used in testing.\n","id":"rulesFor2()","line":"369"},{"returnType":{"name":"Serialization","refId":"serialization/Serialization"},"name":"ruleSerialization","kind":"method","comment":"\nCreate a Serialization for serializing SerializationRules. This is used\nto save the rules in a self-describing format along with the data.\nIf there are new rule classes created, they will need to be described\nhere.\n","id":"ruleSerialization0()","line":"416"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"_hasNameFor","children":[{"name":"object","kind":"param","id":"object"}],"isPrivate":true,"kind":"method","comment":"Return true if our [namedObjects] collection has an entry for [object].","id":"_hasNameFor1()","line":"445"},{"name":"_nameFor","children":[{"name":"object","kind":"param","id":"object"},{"isOptional":true,"name":"ifAbsent","kind":"param","id":"ifAbsent"}],"isPrivate":true,"kind":"method","comment":"\nReturn the name we have for [object] in our [namedObjects] collection or\nthe result of evaluating [ifAbsent] if there is no entry.\n","id":"_nameFor2()","line":"454"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"rules","kind":"property","comment":"\nThe serialization is controlled by the list of Serialization rules. These\nare most commonly added via [addRuleFor].\n","id":"rules","line":"210"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"selfDescribing","kind":"property","comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","id":"selfDescribing","line":"237"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"_rules","isPrivate":true,"kind":"variable","id":"_rules","line":"204"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"namedObjects","kind":"variable","id":"namedObjects","line":"221"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_selfDescribing","isPrivate":true,"kind":"variable","id":"_selfDescribing","line":"229"},{"name":"Serialization","kind":"constructor","comment":"\nCreates a new serialization with a default set of rules for primitives\nand lists.\n","id":"Serialization0()","line":"254"},{"name":"Serialization.blank","kind":"constructor","comment":"\nCreates a new serialization with no default rules at all. The most common\nuse for this is if we are reading self-describing serialized data and\nwill populate the rules from that data.\n","id":"Serialization.blank0()","line":"263"}],"kind":"class","comment":"\nThis class defines a particular serialization scheme, in terms of\n[SerializationRule] instances, and supports reading and writing them.\nSee library comment for examples of usage.\n","id":"Serialization","line":"198"}],"uri":"pkg/serialization/lib/serialization.dart","kind":"library","comment":"\nThis provides a general-purpose serialization facility for Dart objects. A\n[Serialization] is defined in terms of [SerializationRule]s and supports\nreading and writing to different formats.\n\nSetup\n=====\nA simple example of usage is\n\n     var address = new Address();\n     address.street = 'N 34th';\n     address.city = 'Seattle';\n     var serialization = new Serialization()\n         ..addRuleFor(address);\n     String output = serialization.write(address);\n\nThis creates a new serialization and adds a rule for address objects. Right\nnow it has to be passed an address instance because of limitations using\nAddress as a literal. Then we ask the Serialization to write the address\nand we get back a String which is a [JSON] representation of the state of\nit and related objects.\n\nThe version above used reflection to automatically identify the public\nfields of the address object. We can also specify those fields explicitly.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"create\",\n           constructorFields: [\"number\", \"street\"],\n           fields: [\"city\"]);\n\nThis rule still uses reflection to access the fields, but does not try to\nidentify which fields to use, but instead uses only the \"number\" and \"street\"\nfields that we specified. We may also want to tell it to identify the\nfields, but to specifically omit certain fields that we don't want\nserialized.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"\",\n           excludeFields: [\"other\", \"stuff\"]);\n\nWriting Rules\n=============\nWe can also use a completely non-reflective rule to serialize and\nde-serialize objects. This can be more work, but it does work in\ndart2js, where mirrors are not yet implemented. We can specify this in two\nways. First, we can write our own SerializationRule class that has methods\nfor our Address class.\n\n     class AddressRule extends CustomRule {\n       bool appliesTo(instance, Writer w) => instance.runtimeType == Address;\n       getState(instance) => [instance.street, instance.city];\n       create(state) => new Address();\n       setState(Address a, List state) {\n         a.street = state[0];\n         a.city = state[1];\n       }\n     }\n\nThe class needs four different methods. The [appliesTo] method tells us if\nthe rule should be used to write an object. In this example we use a test\nbased on runtimeType. We could also use an \"is Address\" test, but if Address\nhas subclasses that would find those as well, and we want a separate rule\nfor each. The [getState] method should\nreturn all the state of the object that we want to recreate,\nand should be either a Map or a List. If you want to write to human-readable\nformats where it's useful to be able to look at the data as a map from\nfield names to values, then it's better to return it as a map. Otherwise it's\nmore efficient to return it as a list. You just need to be sure that the\n[create] and [setState] methods interpret the same way as [getState] does.\n\nThe [create] method will create the new object and return it. While it's\npossible to create the object and set all its state in this one method, that\nincreases the likelihood of problems with cycles. So it's better to use the\nminimum necessary information in [create] and do more of the work in\n[setState].\n\nThe other way to do this is not creating a subclass, but by using a\n[ClosureRule] and giving it functions for how to create\nthe address.\n\n     addressToMap(a) => {\"number\" : a.number, \"street\" : a.street,\n         \"city\" : a.city};\n     createAddress(Map m) => new Address.create(m[\"number\"], m[\"street\"]);\n     fillInAddress(Address a, Map m) => a.city = m[\"city\"];\n     var serialization = new Serialization()\n       ..addRule(\n           new ClosureRule(anAddress.runtimeType,\n               addressToMap, createAddress, fillInAddress);\n\nIn this case we have created standalone functions rather than\nmethods in a subclass and we pass them to the constructor of\n[ClosureRule]. In this case we've also had them use maps rather than\nlists for the state, but either would work as long as the rule is\nconsistent with the representation it uses. We pass it the runtimeType\nof the object, and functions equivalent to the methods on [CustomRule]\n\nConstant Values\n===============\nThere are cases where the constructor needs values that we can't easily get\nfrom the serialized object. For example, we may just want to pass null, or a\nconstant value. To support this, we can specify as constructor fields\nvalues that aren't field names. If any value isn't a String, it will be\ntreated as a constant and passed unaltered to the constructor.\n\nIn some cases a non-constructor field should not be set using field\naccess or a setter, but should be done by calling a method. For example, it\nmay not be possible to set a List field \"foo\", and you need to call an\naddFoo() method for each entry in the list. In these cases, if you are using\na BasicRule for the object you can call the setFieldWith() method.\n\n      s..addRuleFor(fooHolderInstance).setFieldWith(\"foo\",\n          (parent, value) => for (var each in value) parent.addFoo(value));\n\nWriting\n=======\nTo write objects, we use the write() method.\n\n      var output = serialization.write(someObject);\n\nBy default this uses a representation in which objects are represented as\nmaps keyed by field name, but in which references between objects have been\nconverted into Reference objects. This is then encoded as a [json] string.\n\nWe can write objects in different formats by passing a [Format] object to\nthe [write] method or by getting a [Writer] object. The available formats\ninclude the default, a simple \"flat\" format that doesn't include field names,\nand a simple JSON format that produces output more suitable for talking to\nservices that expect JSON in a predefined format. Examples of these are\n\n     String output = serialization.write(address, new SimpleMapFormat());\n     List output = serialization.write(address, new SimpleFlatFormat());\n     Map output = serialization.write(address, new SimpleJsonFormat());\nOr, using a [Writer] explicitly\n     var writer = serialization.newWriter(new SimpleFlatFormat());\n     var output = writer.write(address);\n\nThese representations are not yet considered stable.\n\nReading\n=======\nTo read objects, the corresponding [read] method can be used.\n\n      Address input = serialization.read(aString);\n\nWhen reading, the serialization instance doing the reading must be configured\nwith compatible rules to the one doing the writing. It's possible for the\nrules to be different, but they need to be able to read the same\nrepresentation. For most practical purposes right now they should be the\nsame. The simplest way to achieve this is by having the serialization\nvariable [selfDescribing] be true. In that case the rules themselves are also\nstored along with the serialized data, and can be read back on the receiving\nend. Note that this may not work for all rules or all formats. The\n[selfDescribing] variable is true by default, but the [SimpleJsonFormat] does\nnot support it, since the point is to provide a representation in a form\nother services might expect. Using CustomRule or ClosureRule also does not\nyet work with the [selfDescribing] variable.\n\nNamed Objects\n=============\nWhen reading, some object references should not be serialized, but should be\nconnected up to other instances on the receiving side. A notable example of\nthis is when serialization rules have been stored. Instances of BasicRule\ntake a [ClassMirror] in their constructor, and we cannot serialize those. So\nwhen we read the rules, we must provide a Map<String, Object> which maps from\nthe simple name of classes we are interested in to a [ClassMirror]. This can\nbe provided either in the [namedObjects] variable of the Serialization,\nor as an additional parameter to the reading and writing methods on the\n[Reader] or [Writer] respectively.\n\n    new Serialization()\n      ..addRuleFor(new Person(), constructorFields: [\"name\"])\n      ..namedObjects['Person'] = reflect(new Person()).type;\n","id":"serialization","line":"180"}