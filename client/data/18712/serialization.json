{"dependencies":[{"id":"dart.core","name":"dart:core","children":[{"id":"Object","name":"Object","children":[{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"==1()","name":"==","children":[{"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","line":"29"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","comment":"\nReturns a string representation of this object.\n","line":"48"},{"id":"noSuchMethod1()","name":"noSuchMethod","children":[{"ref":{"name":"InvocationMirror","refId":"dart.core/InvocationMirror"},"id":"invocation","name":"invocation","kind":"param"}],"kind":"method","comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [InvocationMirror].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","line":"60"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hashCode","name":"hashCode","kind":"property","comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","line":"43"},{"ref":{"name":"Type","refId":"dart.core/Type"},"id":"runtimeType","name":"runtimeType","kind":"property","comment":"\nA representation of the runtime type of the object.\n","line":"65"},{"id":"Object0()","name":"Object","kind":"constructor","comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","line":"18"}],"uri":"sdk/lib/core/object.dart","kind":"class","comment":"\nEverything in Dart is an [Object].\n","line":"10"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Map","name":"Map","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"containsValue1()","name":"containsValue","children":[{"ref":{"name":"V","refId":"dart.core/Map/V"},"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"\nReturns whether this map contains the given [value].\n","line":"26"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"containsKey1()","name":"containsKey","children":[{"ref":{"name":"K","refId":"dart.core/Map/K"},"id":"key","name":"key","kind":"param"}],"kind":"method","comment":"\nReturns whether this map contains the given [key].\n","line":"31"},{"isOperator":true,"returnType":{"name":"V","refId":"dart.core/Map/V"},"id":"[]1()","name":"[]","children":[{"ref":{"name":"K","refId":"dart.core/Map/K"},"id":"key","name":"key","kind":"param"}],"kind":"method","comment":"\nReturns the value for the given [key] or null if [key] is not\nin the map. Because null values are supported, one should either\nuse containsKey to distinguish between an absent key and a null\nvalue, or use the [putIfAbsent] method.\n","line":"39"},{"isOperator":true,"returnType":{"name":"void","refId":"void"},"id":"[]=2()","name":"[]=","children":[{"ref":{"name":"K","refId":"dart.core/Map/K"},"id":"key","name":"key","kind":"param"},{"ref":{"name":"V","refId":"dart.core/Map/V"},"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"\nAssociates the [key] with the given [value].\n","line":"44"},{"returnType":{"name":"V","refId":"dart.core/Map/V"},"id":"putIfAbsent2()","name":"putIfAbsent","children":[{"ref":{"name":"K","refId":"dart.core/Map/K"},"id":"key","name":"key","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"ifAbsent","name":"ifAbsent","children":[{"returnType":{"name":"V","refId":"dart.core/Map/V"},"id":"Function","name":"Function","uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nIf [key] is not associated to a value, calls [ifAbsent] and\nupdates the map by mapping [key] to the value returned by\n[ifAbsent]. Returns the value in the map.\n\nIt is an error to add or remove keys from map during the call to\n[ifAbsent].\n","line":"54"},{"returnType":{"name":"V","refId":"dart.core/Map/V"},"id":"remove1()","name":"remove","children":[{"ref":{"name":"K","refId":"dart.core/Map/K"},"id":"key","name":"key","kind":"param"}],"kind":"method","comment":"\nRemoves the association for the given [key]. Returns the value for\n[key] in the map or null if [key] is not in the map. Note that values\ncan be null and a returned null value does not always imply that the\nkey is absent.\n","line":"62"},{"returnType":{"name":"void","refId":"void"},"id":"clear0()","name":"clear","kind":"method","comment":"\nRemoves all pairs from the map.\n","line":"67"},{"returnType":{"name":"void","refId":"void"},"id":"forEach1()","name":"forEach","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","children":[{"ref":{"name":"K","refId":"dart.core/Map/K"},"id":"key","name":"key","uri":"sdk/lib/core/map.dart","kind":"param","line":"74"},{"ref":{"name":"V","refId":"dart.core/Map/V"},"id":"value","name":"value","uri":"sdk/lib/core/map.dart","kind":"param","line":"74"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nApplies [f] to each {key, value} pair of the map.\n\nIt is an error to add or remove keys from the map during iteration.\n","line":"74"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"K","refId":"dart.core/Map/K"}]},"id":"keys","name":"keys","kind":"property","comment":"\nThe keys of [this].\n","line":"80"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"V","refId":"dart.core/Map/V"}]},"id":"values","name":"values","kind":"property","comment":"\nThe values of [this].\n","line":"85"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","comment":"\nThe number of {key, value} pairs in the map.\n","line":"90"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEmpty","name":"isEmpty","kind":"property","comment":"\nReturns true if there is no {key, value} pair in the map.\n","line":"95"},{"id":"Map0()","name":"Map","kind":"constructor","comment":"\nCreates a map with the default implementation.\n","line":"15"},{"id":"Map.from1()","name":"Map.from","children":[{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"K","refId":"dart.core/Map/K"},{"name":"V","refId":"dart.core/Map/V"}]},"id":"other","name":"other","kind":"param"}],"kind":"constructor","comment":"\nCreates a [Map] that contains all key value pairs of [other].\n","line":"20"},{"id":"K","name":"K","kind":"typeparam"},{"id":"V","name":"V","kind":"typeparam"}],"uri":"sdk/lib/core/map.dart","kind":"class","comment":"\nA [Map] is an associative container, mapping a key to a value.\nNull values are supported, but null keys are not.\n","line":"11"},{"interfaces":[{"name":"Collection","refId":"dart.core/Collection","arguments":[{"name":"E","refId":"dart.core/List/E"}]}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"List","name":"List","children":[{"isOperator":true,"returnType":{"name":"E","refId":"dart.core/List/E"},"id":"[]1()","name":"[]","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nReturns the element at the given [index] in the list or throws\nan [RangeError] if [index] is out of bounds.\n","line":"43"},{"isOperator":true,"returnType":{"name":"void","refId":"void"},"id":"[]=2()","name":"[]=","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"},{"ref":{"name":"E","refId":"dart.core/List/E"},"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"\nSets the entry at the given [index] in the list to [value].\nThrows an [RangeError] if [index] is out of bounds.\n","line":"49"},{"isSetter":true,"returnType":{"name":"void","refId":"void"},"id":"length=1()","name":"length=","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"newLength","name":"newLength","kind":"param"}],"kind":"method","comment":"\nChanges the length of the list. If [newLength] is greater than\nthe current [length], entries are initialized to [:null:]. Throws\nan [UnsupportedError] if the list is not extendable.\n","line":"56"},{"returnType":{"name":"void","refId":"void"},"id":"add1()","name":"add","children":[{"ref":{"name":"E","refId":"dart.core/List/E"},"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"\nAdds [value] at the end of the list, extending the length by\none. Throws an [UnsupportedError] if the list is not\nextendable.\n","line":"63"},{"returnType":{"name":"void","refId":"void"},"id":"addLast1()","name":"addLast","children":[{"ref":{"name":"E","refId":"dart.core/List/E"},"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"\nAdds [value] at the end of the list, extending the length by\none. Throws an [UnsupportedError] if the list is not\nextendable.\n","line":"70"},{"returnType":{"name":"void","refId":"void"},"id":"addAll1()","name":"addAll","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/List/E"}]},"id":"iterable","name":"iterable","kind":"param"}],"kind":"method","comment":"\nAppends all elements of the [iterable] to the end of this list.\nExtends the length of the list by the number of elements in [iterable].\nThrows an [UnsupportedError] if this list is not extensible.\n","line":"77"},{"returnType":{"name":"void","refId":"void"},"id":"sort1()","name":"sort","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"compare","name":"compare","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/List/E"},"id":"a","name":"a","uri":"sdk/lib/core/list.dart","kind":"param","line":"91"},{"ref":{"name":"E","refId":"dart.core/List/E"},"id":"b","name":"b","uri":"sdk/lib/core/list.dart","kind":"param","line":"91"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nSorts the list according to the order specified by the [compare] function.\n\nThe [compare] function must act as a [Comparator].\nThe default [List] implementations use [Comparable.compare] if\n[compare] is omitted.\n","line":"91"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"indexOf2()","name":"indexOf","children":[{"ref":{"name":"E","refId":"dart.core/List/E"},"id":"element","name":"element","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"0","isOptional":true,"id":"start","name":"start","kind":"param"}],"kind":"method","comment":"\nReturns the first index of [element] in the list.\n\nSearches the list from index [start] to the length of the list.\nThe first time an element [:e:] is encountered so that [:e == element:],\nthe index of [:e:] is returned.\nReturns -1 if [element] is not found.\n","line":"101"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"lastIndexOf2()","name":"lastIndexOf","children":[{"ref":{"name":"E","refId":"dart.core/List/E"},"id":"element","name":"element","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"id":"start","name":"start","kind":"param"}],"kind":"method","comment":"\nReturns the last index of [element] in the list.\n\nSearches the list backwards from index [start] (inclusive) to 0.\nThe first time an element [:e:] is encountered so that [:e == element:],\nthe index of [:e:] is returned.\nIf start is not provided, it defaults to [:this.length - 1:] .\nReturns -1 if [element] is not found.\n","line":"112"},{"returnType":{"name":"void","refId":"void"},"id":"clear0()","name":"clear","kind":"method","comment":"\nRemoves all elements in the list.\n\nThe length of the list becomes zero.\nThrows an [UnsupportedError], and retains all elements, if the\nlength of the list cannot be changed.\n","line":"121"},{"returnType":{"name":"E","refId":"dart.core/List/E"},"id":"removeAt1()","name":"removeAt","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nRemoves the element at position[index] from the list.\n\nThis reduces the length of the list by one and moves all later elements\ndown by one position.\nReturns the removed element.\nThrows an [ArgumentError] if [index] is not an [int].\nThrows an [RangeError] if the [index] does not point inside\nthe list.\nThrows an [UnsupportedError], and doesn't remove the element,\nif the length of the list cannot be changed.\n","line":"135"},{"returnType":{"name":"E","refId":"dart.core/List/E"},"id":"removeLast0()","name":"removeLast","kind":"method","comment":"\nPops and returns the last element of the list.\nThrows a [UnsupportedError] if the length of the\nlist cannot be changed.\n","line":"142"},{"returnType":{"name":"List","refId":"dart.core/List","arguments":[{"name":"E","refId":"dart.core/List/E"}]},"id":"getRange2()","name":"getRange","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"start","name":"start","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"}],"kind":"method","comment":"\nReturns a new list containing [length] elements from the list,\nstarting at  [start].\nReturns an empty list if [length] is 0.\nThrows an [ArgumentError] if [length] is negative.\nThrows an [RangeError] if [start] or\n[:start + length - 1:] are out of range.\n","line":"152"},{"returnType":{"name":"void","refId":"void"},"id":"setRange4()","name":"setRange","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"start","name":"start","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"E","refId":"dart.core/List/E"}]},"id":"from","name":"from","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"id":"startFrom","name":"startFrom","kind":"param"}],"kind":"method","comment":"\nCopies [length] elements of [from], starting\nat [startFrom], into the list, starting at [start].\nIf [length] is 0, this method does not do anything.\nThrows an [ArgumentError] if [length] is negative.\nThrows an [RangeError] if [start] or\n[:start + length - 1:] are out of range for [:this:], or if\n[startFrom] or [:startFrom + length - 1:] are out of range for [from].\n","line":"163"},{"returnType":{"name":"void","refId":"void"},"id":"removeRange2()","name":"removeRange","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"start","name":"start","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"}],"kind":"method","comment":"\nRemoves [length] elements from the list, beginning at [start].\nThrows an [UnsupportedError] if the list is\nnot extendable.\nIf [length] is 0, this method does not do anything.\nThrows an [ArgumentError] if [length] is negative.\nThrows an [RangeError] if [start] or\n[:start + length: - 1] are out of range.\n","line":"174"},{"returnType":{"name":"void","refId":"void"},"id":"insertRange3()","name":"insertRange","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"start","name":"start","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"},{"ref":{"name":"E","refId":"dart.core/List/E"},"isOptional":true,"id":"fill","name":"fill","kind":"param"}],"kind":"method","comment":"\nInserts a new range into the list, starting from [start] to\n[:start + length - 1:]. The entries are filled with [fill].\nThrows an [UnsupportedError] if the list is\nnot extendable.\nIf [length] is 0, this method does not do anything.\nIf [start] is the length of the list, this method inserts the\nrange at the end of the list.\nThrows an [ArgumentError] if [length] is negative.\nThrows an [RangeError] if [start] is negative or if\n[start] is greater than the length of the list.\n","line":"188"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/List/E"}]},"id":"reversed","name":"reversed","kind":"property","comment":"\nReturns an [Iterable] of the elements of this [List] in reverse order.\n","line":"82"},{"id":"List1()","name":"List","children":[{"ref":{"name":"int","refId":"dart.core/int"},"defaultValue":"0","isOptional":true,"id":"length","name":"length","kind":"param"}],"kind":"constructor","comment":"\nCreates a list of the given [length].\n\nThe length of the returned list is not fixed.\n","line":"17"},{"id":"List.fixedLength2()","name":"List.fixedLength","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"},{"ref":{"name":"E","refId":"dart.core/List/E"},"isNamed":true,"defaultValue":"null","isOptional":true,"id":"fill","name":"fill","kind":"param"}],"kind":"constructor","comment":"\nCreates a fixed-sized list of the given [length] where each entry is\nfilled with [fill].\n","line":"23"},{"id":"List.from1()","name":"List.from","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"other","name":"other","kind":"param"}],"kind":"constructor","comment":"\nCreates an list with the elements of [other]. The order in\nthe list will be the order provided by the iterator of [other].\n\nThe length of the returned list is not fixed.\n","line":"31"},{"id":"E","name":"E","kind":"typeparam"}],"uri":"sdk/lib/core/list.dart","kind":"class","comment":"\nA [List] is an indexable collection with a length. It can be of\nfixed size or extendable.\n","line":"11"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Iterable","name":"Iterable","children":[{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"map1()","name":"map","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"51"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns a lazy [Iterable] where each element [:e:] of [this] is replaced\nby the result of [:f(e):].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [f] will\nnot be invoked. The transformed elements will not be cached. Iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [f] multiple times on the same element.\n","line":"51"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"where1()","name":"where","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"63"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns a lazy [Iterable] with all elements that satisfy the\npredicate [f].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [f] will\nnot be invoked. Iterating will not cache results, and thus iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [f] multiple times on the same element.\n","line":"63"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"expand1()","name":"expand","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"75"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nExpand each element of this [Iterable] into zero or more elements.\n\nThe resulting Iterable will run through the elements returned\nby [f] for each element of this, in order.\n\nThe returned [Iterable] is lazy, and will call [f] for each element\nof this every time it's iterated.\n","line":"75"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"contains1()","name":"contains","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","kind":"param"}],"kind":"method","comment":"\nCheck whether the collection contains an element equal to [element].\n","line":"81"},{"returnType":{"name":"void","refId":"void"},"id":"forEach1()","name":"forEach","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"91"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nApplies the function [f] to each element of this collection.\n","line":"91"},{"id":"reduce2()","name":"reduce","children":[{"id":"initialValue","name":"initialValue","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"combine","name":"combine","children":[{"id":"Function","name":"Function","children":[{"id":"previousValue","name":"previousValue","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"106"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"106"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"106"}],"kind":"method","comment":"\nReduce a collection to a single value by iteratively combining each element\nof the collection with an existing value using the provided function.\nUse [initialValue] as the initial value, and the function [combine] to\ncreate a new value from the previous one and an element.\n\nExample of calculating the sum of a collection:\n\n  collection.reduce(0, (prev, element) => prev + element);\n","line":"105"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"every1()","name":"every","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"116"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns true if every elements of this collection satisify the\npredicate [f]. Returns false otherwise.\n","line":"116"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"join1()","name":"join","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"separator","name":"separator","kind":"param"}],"kind":"method","comment":"\nConvert each element to a [String] and concatenate the strings.\n\nConverts each element to a [String] by calling [Object.toString] on it.\nThen concatenates the strings, optionally separated by the [separator]\nstring.\n","line":"130"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"any1()","name":"any","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"152"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns true if one element of this collection satisfies the\npredicate [f]. Returns false otherwise.\n","line":"152"},{"returnType":{"name":"List","refId":"dart.core/List","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"toList0()","name":"toList","kind":"method","line":"159"},{"returnType":{"name":"Set","refId":"dart.core/Set","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"toSet0()","name":"toSet","kind":"method","line":"160"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"min1()","name":"min","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"compare","name":"compare","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"a","name":"a","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"188"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"b","name":"b","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"188"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nFind the least element in the iterable.\n\nReturns null if the iterable is empty.\nOtherwise returns an element [:x:] of this [Iterable] so that\n[:x:] is not greater than [:y:] (that is, [:compare(x, y) <= 0:]) for all\nother elements [:y:] in the iterable.\n\nThe [compare] function must be a proper [Comparator<T>]. If a function is\nnot provided, [compare] defaults to [Comparable.compare].\n","line":"188"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"max1()","name":"max","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"compare","name":"compare","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"a","name":"a","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"211"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"b","name":"b","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"211"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nFind the largest element in the iterable.\n\nReturns null if the iterable is empty.\nOtherwise returns an element [:x:] of this [Iterable] so that\n[:x:] is not smaller than [:y:] (that is, [:compare(x, y) >= 0:]) for all\nother elements [:y:] in the iterable.\n\nThe [compare] function must be a proper [Comparator<T>]. If a function is\nnot provided, [compare] defaults to [Comparable.compare].\n","line":"211"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"take1()","name":"take","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"n","name":"n","kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] with at most [n] elements.\n\nThe returned [Iterable] may contain fewer than [n] elements, if [this]\ncontains fewer than [n] elements.\n","line":"234"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"takeWhile1()","name":"takeWhile","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"247"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that stops once [test] is not satisfied anymore.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] will start iterating over the elements of [this].\nWhen the iterator encounters an element [:e:] that does not satisfy [test],\nit discards [:e:] and moves into the finished state. That is, it will not\nask or provide any more elements.\n","line":"247"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"skip1()","name":"skip","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"n","name":"n","kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that skips the first [n] elements.\n\nIf [this] has fewer than [n] elements, then the resulting [Iterable] will\nbe empty.\n","line":"257"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"skipWhile1()","name":"skipWhile","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"270"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that skips elements while [test] is satisfied.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] will iterate over all elements of [this].\nAs long as the iterator's elements do not satisfy [test] they are\ndiscarded. Once an element satisfies the [test] the iterator stops testing\nand uses every element unconditionally.\n","line":"270"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"firstMatching2()","name":"firstMatching","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"325"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"isOptional":true,"id":"orElse","name":"orElse","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the first element that satisfies the given predicate [f].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is `null`, a [StateError] is\nthrown.\n","line":"325"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"lastMatching2()","name":"lastMatching","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"341"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"isOptional":true,"id":"orElse","name":"orElse","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the last element that satisfies the given predicate [f].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is [:null:], a [StateError] is\nthrown.\n","line":"341"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"singleMatching1()","name":"singleMatching","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"360"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the single element that satisfies [f]. If no or more than one\nelement match then a [StateError] is thrown.\n","line":"360"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"elementAt1()","name":"elementAt","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nReturns the [index]th element.\n\nIf [this] [Iterable] has fewer than [index] elements throws a\n[RangeError].\n\nNote: if [this] does not have a deterministic iteration order then the\nfunction may simply return any element without any iteration if there are\nat least [index] elements in [this].\n","line":"387"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"iterator","name":"iterator","kind":"property","comment":"\nReturns an [Iterator] that iterates over this [Iterable] object.\n","line":"39"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","comment":"\nReturns the number of elements in [this].\n\nCounting all elements may be involve running through all elements and can\ntherefore be slow.\n","line":"168"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEmpty","name":"isEmpty","kind":"property","comment":"\nReturns true if there is no element in this collection.\n","line":"226"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"first","name":"first","kind":"property","comment":"\nReturns the first element.\n\nIf [this] is empty throws a [StateError]. Otherwise this method is\nequivalent to [:this.elementAt(0):]\n","line":"280"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"last","name":"last","kind":"property","comment":"\nReturns the last element.\n\nIf [this] is empty throws a [StateError].\n","line":"293"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"single","name":"single","kind":"property","comment":"\nReturns the single element in [this].\n\nIf [this] is empty or has more than one element throws a [StateError].\n","line":"310"},{"id":"Iterable0()","name":"Iterable","kind":"constructor","line":"20"},{"id":"Iterable.generate2()","name":"Iterable.generate","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"count","name":"count","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"generator","name":"generator","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","uri":"sdk/lib/core/iterable.dart","kind":"param","line":"32"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"constructor","comment":"\nCreate an [Iterable] that generates its elements dynamically.\n\nThe [Iterators] created by the [Iterable] will count from\nzero to [:count - 1:] while iterating, and call [generator]\nwith that index to create the next value.\n\nAs an [Iterable], [:new Iterable.generate(n, generator)):] is equivalent to\n[:const [0, ..., n - 1].map(generator):]\n","line":"32"},{"id":"E","name":"E","kind":"typeparam"}],"uri":"sdk/lib/core/iterable.dart","kind":"class","comment":"\nThe [Iterable] interface allows to get an [Iterator] out of an\n[Iterable] object.\n\nThis interface is used by the for-in construct to iterate over an\n[Iterable] object.\nThe for-in construct takes an [Iterable] object at the right-hand\nside, and calls its [iterator] method to get an [Iterator] on it.\n\nA user-defined class that implements the [Iterable] interface can\nbe used as the right-hand side of a for-in construct.\n","line":"19"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"isThrowable":true,"id":"Exception","name":"Exception","children":[{"id":"Exception1()","name":"Exception","children":[{"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"21"}],"uri":"sdk/lib/core/exceptions.dart","kind":"class","comment":"\nA marker interface implemented by all core library exceptions.\n\nAn [Exception] is intended to convey information to the user about a failure,\nso that the error can be addressed programmatically. It is intended to be\ncaught, and it should contain useful data fields.\n\nCreating instances of [Exception] directly with [:new Exception(\"message\"):]\nis discouraged, and only included as a temporary measure during development,\nuntil the actual exceptions used by a library are done.\n","line":"20"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Comparable","name":"Comparable","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"compareTo1()","name":"compareTo","children":[{"ref":{"name":"T","refId":"dart.core/Comparable/T"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nCompares this object to another [Comparable]\n\nReturns a value like a [Comparator] when comparing [:this:] to [other].\n\nMay throw an [ArgumentError] if [other] is of a type that\nis not comparable to [:this:].\n","line":"34"},{"isStatic":true,"returnType":{"name":"int","refId":"dart.core/int"},"id":"compare2()","name":"compare","children":[{"ref":{"name":"Comparable","refId":"dart.core/Comparable"},"id":"a","name":"a","kind":"param"},{"ref":{"name":"Comparable","refId":"dart.core/Comparable"},"id":"b","name":"b","kind":"param"}],"kind":"method","comment":"\nCompare one comparable to another.\n\nThis utility function is used as the default comparator\nfor the [List] sort function.\n","line":"42"},{"id":"T","name":"T","kind":"typeparam"}],"uri":"sdk/lib/core/comparable.dart","kind":"class","comment":"\nInterface used by types that have an intrinsic ordering.\n","line":"25"},{"superclass":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Collection/E"}]},"isAbstract":true,"id":"Collection","name":"Collection","children":[{"returnType":{"name":"void","refId":"void"},"id":"add1()","name":"add","children":[{"ref":{"name":"E","refId":"dart.core/Collection/E"},"id":"element","name":"element","kind":"param"}],"kind":"method","comment":"\nAdds an element to this collection.\n","line":"25"},{"returnType":{"name":"void","refId":"void"},"id":"addAll1()","name":"addAll","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Collection/E"}]},"id":"elements","name":"elements","kind":"param"}],"kind":"method","comment":"\nAdds all of [elements] to this collection.\n\nEquivalent to adding each element in [elements] using [add],\nbut some collections may be able to optimize it.\n","line":"33"},{"returnType":{"name":"void","refId":"void"},"id":"remove1()","name":"remove","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"id":"element","name":"element","kind":"param"}],"kind":"method","comment":"\nRemoves an instance of [element] from this collection.\n\nThis removes only one instance of the element for collections that can\ncontain the same element more than once (e.g., [List]). Which instance\nis removed is decided by the collection.\n\nHas no effect if the elements is not in this collection.\n","line":"48"},{"returnType":{"name":"void","refId":"void"},"id":"removeAll1()","name":"removeAll","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"elements","name":"elements","kind":"param"}],"kind":"method","comment":"\nRemoves all of [elements] from this collection.\n\nEquivalent to calling [remove] once for each element in\n[elements], but may be faster for some collections.\n","line":"56"},{"returnType":{"name":"void","refId":"void"},"id":"retainAll1()","name":"retainAll","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"elements","name":"elements","kind":"param"}],"kind":"method","comment":"\nRemoves all elements of this collection that are not\nin [elements].\n\nFor [Set]s, this is the intersection of the two original sets.\n","line":"66"},{"returnType":{"name":"void","refId":"void"},"id":"removeMatching1()","name":"removeMatching","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Collection/E"},"id":"element","name":"element","uri":"sdk/lib/core/collection.dart","kind":"param","line":"75"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nRemoves all elements of this collection that satisfy [test].\n\nAn elements [:e:] satisfies [test] if [:test(e):] is true.\n","line":"75"},{"returnType":{"name":"void","refId":"void"},"id":"retainMatching1()","name":"retainMatching","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Collection/E"},"id":"element","name":"element","uri":"sdk/lib/core/collection.dart","kind":"param","line":"84"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nRemoves all elements of this collection that fail to satisfy [test].\n\nAn elements [:e:] satisfies [test] if [:test(e):] is true.\n","line":"84"},{"returnType":{"name":"void","refId":"void"},"id":"clear0()","name":"clear","kind":"method","comment":"\nRemoves all elements of this collection.\n","line":"91"},{"id":"Collection0()","name":"Collection","kind":"constructor","line":"20"},{"id":"E","name":"E","kind":"typeparam"}],"uri":"sdk/lib/core/collection.dart","kind":"class","comment":"\nA collection of individual elements.\n\nA [Collection] contains some elements in a structure optimized\nfor certain operations. Different collections are optimized for different\nuses.\n\nA collection can be updated by adding or removing elements.\n\nCollections are [Iterable]. The order of iteration is defined by\neach type of collection.\n","line":"19"}],"uri":"sdk/lib/core/core.dart","kind":"library","line":"5"}],"id":"serialization","name":"package:serialization/serialization.dart","children":[{"id":"_lazy2()","name":"_lazy","children":[{"id":"l","name":"l","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"method","comment":"Create a lazy list/map that will inflate its items on demand in [r]. ","isPrivate":true,"line":"472"},{"superclass":{"name":"Format","refId":"serialization/Format"},"id":"SimpleFlatFormat","name":"SimpleFlatFormat","children":[{"returnType":{"name":"List","refId":"dart.core/List"},"id":"generateOutput1()","name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nGenerate output for this format from [w]. This will return a List with\nthree entries, corresponding to the \"rules\", \"data\", and \"roots\" from\n[SimpleMapFormat]. The data is stored as a single List containing\nprimitives.\n","line":"250"},{"returnType":{"name":"void","refId":"void"},"id":"writeStateInto3()","name":"writeStateInto","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"ruleData","name":"ruleData","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nWrites the data from [rule] into the [target] list.\n","line":"268"},{"id":"writeLists3()","name":"writeLists","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"id":"entries","name":"entries","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nWrite [entries], which contains Lists. Either the lists are variable\nlength, in which case we add a length field, or they are fixed length, in\nwhich case we don't, and assume the [rule] will know how to read the\nright length when we read it back. We expect everything in the list to be\na reference, which is stored as two numbers.\n","line":"293"},{"id":"writeMaps3()","name":"writeMaps","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Map","refId":"dart.core/Map"}]},"id":"entries","name":"entries","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nWrite [entries], which contains Maps. Either the Maps are variable\nlength, in which case we add a length field, or they are fixed length, in\nwhich case we don't, and assume the [rule] will know how to read the\nright length when we read it back. Then we write alternating keys and\nvalues. We expect the values to be references, which we store as\ntwo numbers.\n","line":"313"},{"id":"writeObjects2()","name":"writeObjects","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"entries","name":"entries","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nWrite [entries], which contains simple objects which we can put directly\ninto [target].\n","line":"330"},{"returnType":{"name":"void","refId":"void"},"id":"writeReference2()","name":"writeReference","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"id":"eachRef","name":"eachRef","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nWrite [eachRef] to [target]. It will be written as two ints. If [eachRef]\nis null it will be written as two nulls.\n","line":"342"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"read2()","name":"read","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"rawInput","name":"rawInput","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"\nRead the data from [rawInput] in the context of [r] and return it as a\nMap with entries for \"roots\", \"data\" and \"rules\", which the reader knows\nhow to interpret. We expect [rawInput] to have been generated from this\nformat.\n","line":"357"},{"id":"readRuleDataFrom3()","name":"readRuleDataFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"\nRead the data for [rule] from [input] and return it.\n","line":"386"},{"id":"readLists4()","name":"readLists","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"\nRead data for [rule] from [input] with [length] number of entries,\ncreating lists from the results.\n","line":"409"},{"id":"readMaps4()","name":"readMaps","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"\nRead data for [rule] from [input] with [length] number of entries,\ncreating maps from the results.\n","line":"427"},{"id":"readPrimitives3()","name":"readPrimitives","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"param"}],"kind":"method","comment":"\nRead data for [rule] from [input] with [length] number of entries,\ntreating the data as primitives that can be returned directly.\n","line":"447"},{"id":"nextReferenceFrom2()","name":"nextReferenceFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"input","name":"input","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"Read the next Reference from the input. ","line":"456"},{"id":"_next1()","name":"_next","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"Return the next element from the input. ","isPrivate":true,"line":"467"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"shouldUseReferencesForPrimitives","name":"shouldUseReferencesForPrimitives","kind":"property","line":"234"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"isStatic":true,"id":"STORED_AS_LIST","name":"STORED_AS_LIST","kind":"variable","line":"240"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"isStatic":true,"id":"STORED_AS_MAP","name":"STORED_AS_MAP","kind":"variable","line":"241"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"isStatic":true,"id":"STORED_AS_PRIMITIVE","name":"STORED_AS_PRIMITIVE","kind":"variable","line":"242"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nWrites to a simple mostly-flat format. Details are subject to change.\nRight now this produces a List containing null, num, and String. This is\nmore space-efficient than the map formats, but much less human-readable.\nSimple usage is to turn this into JSON for transmission.\n","line":"233"},{"superclass":{"name":"Format","refId":"serialization/Format"},"id":"SimpleJsonFormat","name":"SimpleJsonFormat","children":[{"id":"generateOutput1()","name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nGenerate output for this format from [w] and return it as\nthe [json] representation of a nested Map structure.\n","line":"112"},{"id":"jsonify1()","name":"jsonify","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nConvert the data generated by the rules to have nested maps instead\nof Reference objects and to add rule numbers if [storeRoundTripInfo]\nis true.\n","line":"129"},{"id":"jsonifyForRule3()","name":"jsonifyForRule","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"ruleData","name":"ruleData","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"}],"kind":"method","comment":"\nFor a particular [rule] modify the [ruleData] to conform to this format.\n","line":"139"},{"id":"jsonifyEntry2()","name":"jsonifyEntry","children":[{"id":"map","name":"map","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nFor one particular entry, which is either a Map or a List, update it\nto turn References into a nested List/Map.\n","line":"156"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"read2()","name":"read","children":[{"id":"data","name":"data","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"\nRead serialized data saved in this format, which should look like\neither a simple type, a List or a Map and return the Map\nrepresentation that the reader expects, with top-level\nentries for \"rules\", \"data\", and \"roots\". Nested lists/maps will be\nconverted into Reference objects. Note that if the data was not written\nwith [storeRoundTripInfo] true this will fail.\n","line":"176"},{"id":"recursivelyFixUp3()","name":"recursivelyFixUp","children":[{"id":"input","name":"input","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"result","name":"result","kind":"param"}],"kind":"method","comment":"\nConvert nested references in [data] into [Reference] objects.\n","line":"200"},{"isFinal":true,"ref":{"name":"bool","refId":"dart.core/bool"},"id":"storeRoundTripInfo","name":"storeRoundTripInfo","kind":"variable","line":"96"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"RULE","name":"RULE","kind":"variable","line":"101"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"RULES","name":"RULES","kind":"variable","line":"102"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"DATA","name":"DATA","kind":"variable","line":"103"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"ROOTS","name":"ROOTS","kind":"variable","line":"104"},{"id":"SimpleJsonFormat1()","name":"SimpleJsonFormat","children":[{"initializedField":{"name":"storeRoundTripInfo","refId":"serialization/SimpleJsonFormat/storeRoundTripInfo"},"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"storeRoundTripInfo","name":"storeRoundTripInfo","kind":"param"}],"kind":"constructor","line":"106"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nA format for \"normal\" [json] representation of objects. It stores\nthe fields of the objects as nested maps, and doesn't allow cycles. This can\nbe useful in talking to existing APIs that expect [json] format data. The\noutput will be either a simple object (string, num, bool), a List, or a Map,\nwith nesting of those.\nNote that since the classes of objects aren't normally stored, this isn't\nenough information to read back the objects. However, if the\nIf the [storeRoundTripData] field of the format is set to true, then this\nwill store the rule number along with the data, allowing reconstruction.\n","line":"88"},{"superclass":{"name":"Format","refId":"serialization/Format"},"id":"SimpleMapFormat","name":"SimpleMapFormat","children":[{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"generateOutput1()","name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nGenerate output for this format from [w] and return it as a String which\nis the [json] representation of a nested Map structure. The top level has\n3 fields, \"rules\" which may hold a definition of the rules used,\n\"data\" which holds the serialized data, and \"roots\", which holds\n[Reference] objects indicating the root objects. Note that roots are\nnecessary because the data is organized in the same way as the object\nstructure, it's a list of lists holding self-contained maps which only\nrefer to other parts via [Reference] objects.\nThis effectively defines a custom JSON serialization format, although\nthe details of the format vary depending which rules were used.\n","line":"55"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"read2()","name":"read","children":[{"id":"topLevel","name":"topLevel","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"\nRead a [json] compatible representation of serialized data in this format\nand return the nested Map representation described in [generateOutput]. If\nthe data also includes rule definitions, then these will replace the rules\nin the [Serialization] for [reader].\n","line":"70"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nA format that stores the data in maps which are converted into a JSON\nstring. Note that the maps aren't nested, and it handles cyclic references\nby converting object references to [Reference] objects. If you want simple\nacyclic JSON look at [SimpleJsonFormat].\n","line":"41"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Format","name":"Format","children":[{"id":"generateOutput1()","name":"generateOutput","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nGenerate output for [w] and return it. The particular form of the output\nwill depend on the format. The format can assume that [w] has data\ngenerated by rules in a series of lists, and that each list will contain\neither primitives (null, bool, num, String), Lists or Maps. The Lists or\nMaps may contain any of the same things recursively, or may contain\nReference objects. For lists and maps the rule will tell us if they can\nbe of variable length or not. The format is allowed to operate\ndestructively on the rule data.\n","line":"25"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"read2()","name":"read","children":[{"id":"input","name":"input","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"\nRead the data from [input] in the context of [reader] and return it as a\nMap with entries for \"roots\", \"data\" and \"rules\", which the reader knows\nhow to interpret. The type of [input] will depend on the particular format.\n","line":"32"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"shouldUseReferencesForPrimitives","name":"shouldUseReferencesForPrimitives","kind":"property","comment":"\nReturn true if this format stores primitives in their own area and uses\nreferences to them (e.g. [SimpleFlatFormat]) and false if primitives\nare stored directly (e.g. [SimpleJsonFormat], [SimpleMapFormat]).\n","line":"13"}],"uri":"pkg/serialization/lib/src/format.dart","kind":"class","comment":"\nAn abstract class for serialization formats. Subclasses define how data\nis read or written to a particular output mechanism.\n","line":"7"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"_MapWrapper","name":"_MapWrapper","children":[{"isOperator":true,"id":"[]1()","name":"[]","children":[{"id":"key","name":"key","kind":"param"}],"kind":"method","line":"626"},{"isOperator":true,"id":"[]=2()","name":"[]=","children":[{"id":"key","name":"key","kind":"param"},{"id":"value","name":"value","kind":"param"}],"kind":"method","line":"628"},{"id":"asMap0()","name":"asMap","kind":"method","line":"631"},{"id":"length","name":"length","kind":"property","line":"629"},{"isFinal":true,"id":"_map","name":"_map","kind":"variable","isPrivate":true,"line":"621"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"fieldList","name":"fieldList","kind":"variable","line":"622"},{"id":"_MapWrapper1()","name":"_MapWrapper","children":[{"initializedField":{"name":"fieldList","refId":"serialization/_MapWrapper/fieldList"},"ref":{"name":"List","refId":"dart.core/List"},"id":"fieldList","name":"fieldList","kind":"param"}],"kind":"constructor","line":"623"},{"id":"_MapWrapper.fromMap2()","name":"_MapWrapper.fromMap","children":[{"initializedField":{"name":"_map","refId":"serialization/_MapWrapper/_map"},"id":"_map","name":"_map","kind":"param","isPrivate":true},{"initializedField":{"name":"fieldList","refId":"serialization/_MapWrapper/fieldList"},"ref":{"name":"List","refId":"dart.core/List"},"id":"fieldList","name":"fieldList","kind":"param"}],"kind":"constructor","line":"624"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis wraps a map to make it indexable by integer field numbers. It translates\nfrom the index into a field name and then looks it up in the map.\n","isPrivate":true,"line":"620"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Constructor","name":"Constructor","children":[{"id":"constructFrom2()","name":"constructFrom","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"\nFind the field values in [state] and pass them to the constructor.\nIf any of [fieldNumbers] is not an int, then use it as a literal value.\n","line":"607"},{"isFinal":true,"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"id":"type","name":"type","kind":"variable","line":"582"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"variable","line":"585"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"id":"fieldNumbers","name":"fieldNumbers","kind":"variable","line":"592"},{"id":"Constructor3()","name":"Constructor","children":[{"initializedField":{"name":"type","refId":"serialization/Constructor/type"},"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"id":"type","name":"type","kind":"param"},{"initializedField":{"name":"name","refId":"serialization/Constructor/name"},"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"initializedField":{"name":"fieldNumbers","refId":"serialization/Constructor/fieldNumbers"},"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"id":"fieldNumbers","name":"fieldNumbers","kind":"param"}],"kind":"constructor","comment":"\nCreates a new constructor for the [type] with the constructor named [name]\nand the [fieldNumbers] of the constructor fields.\n","line":"598"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a constructor that is to be used when re-creating a\nserialized object.\n","line":"580"},{"id":"SetWithFunction","name":"SetWithFunction","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"m","name":"m","kind":"param"},{"id":"object","name":"object","kind":"param"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"typedef","comment":"\n Provide a typedef for the setWith argument to setFieldWith. It would\nbe nice if we could put this closer to the definition.\n","line":"574"},{"superclass":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"_FieldList","name":"_FieldList","children":[{"returnType":{"name":"_Field","refId":"serialization/_Field"},"id":"named1()","name":"named","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"method","comment":"Look up a field by [name]. ","line":"444"},{"isSetter":true,"id":"constructorFields=1()","name":"constructorFields=","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"fieldNames","name":"fieldNames","kind":"param"}],"kind":"method","comment":"Set the fields to be used in the constructor. ","line":"447"},{"isSetter":true,"id":"regular=1()","name":"regular=","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"fields","name":"fields","kind":"param"}],"kind":"method","comment":"Set the fields that aren't used in the constructor. ","line":"459"},{"isSetter":true,"id":"exclude=1()","name":"exclude=","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"fields","name":"fields","kind":"param"}],"kind":"method","comment":"Set the fields to be excluded. This is mutually exclusive with setting\nthe regular fields.\n","line":"468"},{"returnType":{"name":"void","refId":"void"},"id":"addAllNotExplicitlyExcluded1()","name":"addAllNotExplicitlyExcluded","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"aCollection","name":"aCollection","kind":"param"}],"kind":"method","comment":"Add all the fields which aren't on the exclude list. ","line":"480"},{"returnType":{"name":"void","refId":"void"},"id":"addAllByName1()","name":"addAllByName","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"names","name":"names","kind":"param"}],"kind":"method","comment":"Add all the fields with the given names without any special properties. ","line":"488"},{"returnType":{"name":"void","refId":"void"},"id":"invalidate0()","name":"invalidate","kind":"method","comment":"\nFields have been added. In case we had already forced calculation of the\nlist of contents, re-set it.\n","line":"499"},{"returnType":{"name":"void","refId":"void"},"id":"forEachRegularField1()","name":"forEachRegularField","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","kind":"param"}],"kind":"method","comment":"Iterate over the regular fields, i.e. those not used in the constructor.","line":"517"},{"returnType":{"name":"void","refId":"void"},"id":"forEachConstructorField1()","name":"forEachConstructorField","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","kind":"param"}],"kind":"method","comment":"Iterate over the fields used in the constructor. ","line":"526"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"constructorFieldNames0()","name":"constructorFieldNames","kind":"method","line":"535"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"constructorFieldIndices0()","name":"constructorFieldIndices","kind":"method","line":"537"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"regularFields0()","name":"regularFields","kind":"method","line":"539"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"regularFieldNames0()","name":"regularFieldNames","kind":"method","line":"540"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"regularFieldIndices0()","name":"regularFieldIndices","kind":"method","line":"541"},{"returnType":{"name":"void","refId":"void"},"id":"figureOutFields0()","name":"figureOutFields","kind":"method","comment":"\nIf we weren't given any non-constructor fields to use, figure out what\nwe think they ought to be, based on the class definition.\nWe find public fields, getters that have corresponding setters, and getters\nthat are listed in the constructor fields.\n","line":"550"},{"id":"toString0()","name":"toString","kind":"method","line":"567"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","line":"477"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"iterator","name":"iterator","kind":"property","line":"504"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"_Field","refId":"serialization/_Field"}]},"id":"contents","name":"contents","kind":"property","comment":"Return a cached, sorted list of all the fields. ","line":"507"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"constructorFields","name":"constructorFields","kind":"property","line":"534"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"_Field","refId":"serialization/_Field"}]},"id":"allFields","name":"allFields","kind":"variable","line":"420"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"_constructorFields","name":"_constructorFields","kind":"variable","isPrivate":true,"line":"427"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"_excludeFields","name":"_excludeFields","kind":"variable","isPrivate":true,"line":"430"},{"isFinal":true,"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"id":"mirror","name":"mirror","kind":"variable","line":"433"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"_Field","refId":"serialization/_Field"}]},"id":"_contents","name":"_contents","kind":"variable","isPrivate":true,"line":"436"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_shouldFigureOutFields","name":"_shouldFigureOutFields","kind":"variable","isPrivate":true,"line":"439"},{"id":"_FieldList1()","name":"_FieldList","children":[{"initializedField":{"name":"mirror","refId":"serialization/_FieldList/mirror"},"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"id":"mirror","name":"mirror","kind":"param"}],"kind":"constructor","line":"441"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThe organization of fields in an object can be reasonably complex, so they\nare kept in a separate object, which also has the ability to compute the\ndefault fields to use reflectively.\n","isPrivate":true,"line":"415"},{"superclass":{"name":"_Field","refId":"serialization/_Field"},"id":"_ConstantField","name":"_ConstantField","children":[{"isOperator":true,"id":"==1()","name":"==","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"396"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"398"},{"id":"valueIn1()","name":"valueIn","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"mirror","name":"mirror","kind":"param"}],"kind":"method","line":"399"},{"returnType":{"name":"void","refId":"void"},"id":"setValue2()","name":"setValue","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"object","name":"object","kind":"param"},{"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"We cannot be set, so setValue is a no-op. ","line":"402"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hashCode","name":"hashCode","kind":"property","line":"397"},{"id":"name","name":"name","kind":"property","comment":"There are places where the code expects us to have an identifier, so\nuse the value for that.\n","line":"407"},{"isFinal":true,"id":"value","name":"value","kind":"variable","line":"392"},{"id":"_ConstantField._internal2()","name":"_ConstantField._internal","children":[{"initializedField":{"name":"value","refId":"serialization/_ConstantField/value"},"id":"value","name":"value","kind":"param"},{"id":"fieldList","name":"fieldList","kind":"param"}],"kind":"constructor","isPrivate":true,"line":"394"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a constant value that will be passed as a constructor\nparameter. Rather than having a name it has a constant value.\n","isPrivate":true,"line":"389"},{"superclass":{"name":"_Field","refId":"serialization/_Field"},"id":"_NamedField","name":"_NamedField","children":[{"isOperator":true,"id":"==1()","name":"==","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"355"},{"returnType":{"name":"void","refId":"void"},"id":"setValue2()","name":"setValue","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"object","name":"object","kind":"param"},{"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"Set the [value] of our field in the given mirrored [object]. ","line":"366"},{"id":"valueIn1()","name":"valueIn","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"mirror","name":"mirror","kind":"param"}],"kind":"method","line":"370"},{"returnType":{"name":"void","refId":"void"},"id":"defaultSetter2()","name":"defaultSetter","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"object","name":"object","kind":"param"},{"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"Return a default setter function. ","line":"378"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"382"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hashCode","name":"hashCode","kind":"property","line":"356"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEssential","name":"isEssential","kind":"property","comment":"\nReturn true if this field is treated as essential state, either because\nit is used in the constructor, or because it's been designated\nusing [setFieldWith].\n","line":"363"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"setter","name":"setter","kind":"property","comment":"Return the function to use to set our value. ","line":"374"},{"isFinal":true,"id":"name","name":"name","kind":"variable","line":"348"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"customSetter","name":"customSetter","kind":"variable","line":"351"},{"id":"_NamedField._internal2()","name":"_NamedField._internal","children":[{"initializedField":{"name":"name","refId":"serialization/_NamedField/name"},"id":"name","name":"name","kind":"param"},{"id":"fieldList","name":"fieldList","kind":"param"}],"kind":"constructor","isPrivate":true,"line":"353"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a field in the object, either stored as a field or\naccessed via getter/setter/constructor parameter. It has a name and\nwill attempt to access the state for that name using an [InstanceMirror].\n","isPrivate":true,"line":"346"},{"interfaces":[{"name":"Comparable","refId":"dart.core/Comparable","arguments":[{"name":"_Field","refId":"serialization/_Field"}]}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"_Field","name":"_Field","children":[{"isStatic":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_isReallyAField2()","name":"_isReallyAField","children":[{"id":"value","name":"value","kind":"param"},{"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"id":"fieldList","name":"fieldList","kind":"param"}],"kind":"method","comment":"\nDetermine if [value] represents a field or getter in the class that\n[fieldList] models.\n","isPrivate":true,"line":"305"},{"id":"valueIn1()","name":"valueIn","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"mirror","name":"mirror","kind":"param"}],"kind":"method","comment":"\nExtracts the value for the field that this represents from the instance\nmirrored by [mirror] and return it.\n","line":"318"},{"returnType":{"name":"void","refId":"void"},"id":"setValue2()","name":"setValue","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"object","name":"object","kind":"param"},{"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"Set the [value] of our field in the given mirrored [object]. ","line":"333"},{"id":"compareTo1()","name":"compareTo","children":[{"ref":{"name":"_Field","refId":"serialization/_Field"},"id":"x","name":"x","kind":"param"}],"kind":"method","line":"338"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isRegular","name":"isRegular","kind":"property","comment":"Return true if this is field is not used in the constructor. ","line":"323"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEssential","name":"isEssential","kind":"property","comment":"\nReturn true if this field is treated as essential state, either because\nit is used in the constructor, or because it's been designated\nusing [setFieldWith].\n","line":"330"},{"isFinal":true,"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"id":"fieldList","name":"fieldList","kind":"variable","line":"277"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"variable","line":"283"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"usedInConstructor","name":"usedInConstructor","kind":"variable","line":"286"},{"id":"_Field2()","name":"_Field","children":[{"id":"value","name":"value","kind":"param"},{"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"id":"fieldList","name":"fieldList","kind":"param"}],"kind":"constructor","comment":"\nCreate a new [_Field] instance. This will be either a [_NamedField] or a\n[_ConstantField] depending on whether or not [value] corresponds to a\nfield in the class which [fieldList] models.\n","line":"293"},{"id":"_Field._internal1()","name":"_Field._internal","children":[{"initializedField":{"name":"fieldList","refId":"serialization/_Field/fieldList"},"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"id":"fieldList","name":"fieldList","kind":"param"}],"kind":"constructor","comment":"Private constructor. ","isPrivate":true,"line":"312"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a field in an object. It is intended to be used as part of\na [_FieldList].\n","isPrivate":true,"line":"274"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"BasicRule","name":"BasicRule","children":[{"id":"setFieldWith2()","name":"setFieldWith","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"fieldName","name":"fieldName","kind":"param"},{"ref":{"name":"SetWithFunction","refId":"serialization/SetWithFunction"},"id":"setWith","name":"setWith","kind":"param"}],"kind":"method","comment":"\nSometimes it's necessary to treat fields of an object differently, based\non the containing object. For example, by default a list treats its\ncontents as non-essential state, so it will be populated only after all\nobjects have been created. An object may have a list which is used in its\nconstructor and must be fully created before the owning object can be\ncreated. Alternatively, it may not be possible to set a field directly,\nand some other method must be called to set it, perhaps calling a method\non the owning object to add each individual element.\n\nThis method lets you designate a function to use to set the value of a\nfield. It also makes the contents of that field be treated as essential,\nwhich currently only has meaning if the field is a list. This is done\nbecause you might set a list field's special treatment function to add\neach item individually and that will only work if those objects already\nexist.\n\nFor example, to serialize a Serialization, we need its rules to be\nindividually added rather than just setting the rules field.\n     ..addRuleFor(new Serialization()).setFieldWith('rules',\n         (InstanceMirror s, List rules) {\n           rules.forEach((x) => s.reflectee.addRule(x));\nNote that the function is passed the owning object as well as the field\nvalue, but that it is passed as a mirror.\n","line":"95"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"111"},{"id":"configureForMaps0()","name":"configureForMaps","kind":"method","comment":"\nConfigure this instance to use maps by field name as its output.\nInstances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","line":"119"},{"id":"configureForLists0()","name":"configureForLists","kind":"method","comment":"\nConfigure this instance to use lists accessing fields by index as its\noutput. Instances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","line":"129"},{"id":"createStateHolder0()","name":"createStateHolder","kind":"method","comment":"Create either a list or a map to hold the object's state, depending\non the [useMaps] variable. If using a Map, we wrap it in order to keep\nthe protocol compatible. See [configureForLists]/[configureForMaps].\n","line":"137"},{"id":"makeIndexableByNumber1()","name":"makeIndexableByNumber","children":[{"id":"state","name":"state","kind":"param"}],"kind":"method","comment":"\nWrap the state if it's passed in as a map, and if the keys are references,\nresolve them to the strings we expect. We leave the previous keys in there\nas well, as they shouldn't be harmful, and it costs more to remove them.\n","line":"145"},{"id":"extractState3()","name":"extractState","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"callback","name":"callback","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nExtract the state from [object] using an instanceMirror and the field\nnames in [fields]. Call the function [callback] on each value.\n","line":"164"},{"id":"flatten2()","name":"flatten","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","line":"178"},{"id":"checkForEssentialLists2()","name":"checkForEssentialLists","children":[{"id":"index","name":"index","kind":"param"},{"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"\nIf the value is a List, and the field is a constructor field or\notherwise specially designated, we wrap it in something that indicates\na restriction on the rules that can be used. Which in this case amounts\nto designating the rule, since we so far only have one rule per object.\n","line":"198"},{"id":"_unwrap1()","name":"_unwrap","children":[{"id":"result","name":"result","kind":"param"}],"kind":"method","comment":"Remove any MapWrapper from the extracted state. ","isPrivate":true,"line":"208"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"\nCall the designated constructor with the appropriate fields from [state],\nfirst resolving references in the context of [reader].\n","line":"214"},{"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"id":"rawState","name":"rawState","kind":"param"},{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"For all [state] not required in the constructor, set it in the [object],\nresolving references in the context of [reader].\n","line":"223"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nDetermine if this rule applies to the object in question. In our case\nthis is true if the type mirrors are the same.\n","line":"237"},{"returnType":{"name":"void","refId":"void"},"id":"_findFields3()","name":"_findFields","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"constructorFields","name":"constructorFields","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"regularFields","name":"regularFields","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"excludeFields","name":"excludeFields","kind":"param","line":"244"}],"kind":"method","comment":"\nGiven the various field lists provided by the user, construct the list\nof field names that we want.\n","isPrivate":true,"line":"243"},{"id":"_value2()","name":"_value","children":[{"ref":{"name":"InstanceMirror","refId":"dart.mirrors/InstanceMirror"},"id":"mirror","name":"mirror","kind":"param"},{"ref":{"name":"_Field","refId":"serialization/_Field"},"id":"field","name":"field","kind":"param"}],"kind":"method","comment":"\nExtract the value of [field] from the object reflected\nby [mirror].\n","isPrivate":true,"line":"267"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"constructorName","name":"constructorName","kind":"property","comment":"Return the name of the constructor used to create new instances on read.","line":"103"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"constructorFields","name":"constructorFields","kind":"property","comment":"Return the list of field names to be passed to the constructor.","line":"106"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"regularFields","name":"regularFields","kind":"property","comment":"Return the list of field names not used in the constructor. ","line":"109"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"hasVariableLengthEntries","name":"hasVariableLengthEntries","kind":"property","line":"253"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"dataLength","name":"dataLength","kind":"property","line":"255"},{"isFinal":true,"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"id":"type","name":"type","kind":"variable","line":"25"},{"ref":{"name":"Constructor","refId":"serialization/Constructor"},"id":"constructor","name":"constructor","kind":"variable","line":"28"},{"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"id":"fields","name":"fields","kind":"variable","line":"31"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"useMaps","name":"useMaps","kind":"variable","line":"38"},{"id":"BasicRule5()","name":"BasicRule","children":[{"initializedField":{"name":"type","refId":"serialization/BasicRule/type"},"ref":{"name":"ClassMirror","refId":"dart.mirrors/ClassMirror"},"id":"type","name":"type","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"constructorName","name":"constructorName","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"constructorFields","name":"constructorFields","kind":"param","line":"62"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"regularFields","name":"regularFields","kind":"param","line":"62"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"excludeFields","name":"excludeFields","kind":"param","line":"63"}],"kind":"constructor","comment":"\nCreate this rule. Right now the user is obliged to pass a ClassMirror,\nbut once we allow class literals (Issue 6282) it will support that. The\nother parameters can all be left as null, and are optional on the\n[Serialization.addRule] method which is the normal caller for this.\n[constructorName] is the constructor, if not the default.\n[constructorFields] are the fields required to call the constructor, which\n  is the essential state. They don't have to be actual fields,\n  getter/setter pairs or getter/constructor pairs are fine. Note that\n  the constructorFields do not need to be strings, they can be arbitrary\n  values. For non-strings, these will be treated as constant values to be\n  used instead of data read from the objects.\n[regularFields] are the non-essential fields. They don't have to be actual\n  fields, getter/setter pairs are fine. If this is null, it's assumed\n  that we should figure them out.\n[excludeFields] lets you tell it to find the fields automatically, but\n  omit some that would otherwise be included.\n","line":"61"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis is the basic rule for handling \"normal\" objects, which have a list of\nfields and a constructor, as opposed to simple types or collections. It uses\nmirrors to access the state, and can also use them to figure out the list\nof fields and the constructor if it's not provided.\n\nIf you call [Serialization.addRule], this is what you get.\n\n","line":"20"},{"interfaces":[{"name":"List","refId":"dart.core/List"}],"superclass":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"_LazyList","name":"_LazyList","children":[{"isOperator":true,"id":"[]1()","name":"[]","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"530"},{"id":"indexOf2()","name":"indexOf","children":[{"id":"x","name":"x","kind":"param"},{"defaultValue":"0","isOptional":true,"id":"pos","name":"pos","kind":"param"}],"kind":"method","line":"542"},{"id":"lastIndexOf2()","name":"lastIndexOf","children":[{"id":"x","name":"x","kind":"param"},{"isOptional":true,"id":"pos","name":"pos","kind":"param"}],"kind":"method","line":"543"},{"id":"_throw0()","name":"_throw","kind":"method","isPrivate":true,"line":"546"},{"isOperator":true,"id":"[]=2()","name":"[]=","children":[{"id":"x","name":"x","kind":"param"},{"id":"y","name":"y","kind":"param"}],"kind":"method","line":"549"},{"id":"add1()","name":"add","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"550"},{"id":"addLast1()","name":"addLast","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"551"},{"id":"addAll1()","name":"addAll","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"552"},{"id":"sort1()","name":"sort","children":[{"isOptional":true,"id":"f","name":"f","kind":"param"}],"kind":"method","line":"553"},{"id":"clear0()","name":"clear","kind":"method","line":"554"},{"id":"removeAt1()","name":"removeAt","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"555"},{"id":"remove1()","name":"remove","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"556"},{"id":"removeLast0()","name":"removeLast","kind":"method","line":"557"},{"id":"removeAll1()","name":"removeAll","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"558"},{"id":"retainAll1()","name":"retainAll","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"559"},{"id":"removeMatching1()","name":"removeMatching","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"560"},{"id":"retainMatching1()","name":"retainMatching","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"561"},{"id":"getRange2()","name":"getRange","children":[{"id":"x","name":"x","kind":"param"},{"id":"y","name":"y","kind":"param"}],"kind":"method","line":"562"},{"id":"setRange4()","name":"setRange","children":[{"id":"x","name":"x","kind":"param"},{"id":"y","name":"y","kind":"param"},{"id":"z","name":"z","kind":"param"},{"isOptional":true,"id":"a","name":"a","kind":"param"}],"kind":"method","line":"563"},{"id":"removeRange2()","name":"removeRange","children":[{"id":"x","name":"x","kind":"param"},{"id":"y","name":"y","kind":"param"}],"kind":"method","line":"564"},{"id":"insertRange3()","name":"insertRange","children":[{"id":"x","name":"x","kind":"param"},{"id":"y","name":"y","kind":"param"},{"isOptional":true,"id":"z","name":"z","kind":"param"}],"kind":"method","line":"565"},{"isSetter":true,"returnType":{"name":"void","refId":"void"},"id":"length=1()","name":"length=","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"567"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","line":"532"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEmpty","name":"isEmpty","kind":"property","line":"533"},{"id":"first","name":"first","kind":"property","line":"534"},{"id":"last","name":"last","kind":"property","line":"535"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"_inflated","name":"_inflated","kind":"property","isPrivate":true,"line":"540"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"id":"iterator","name":"iterator","kind":"property","line":"541"},{"id":"reversed","name":"reversed","kind":"property","line":"566"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List"},"id":"_raw","name":"_raw","kind":"variable","isPrivate":true,"line":"526"},{"isFinal":true,"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"_reader","name":"_reader","kind":"variable","isPrivate":true,"line":"527"},{"id":"_LazyList2()","name":"_LazyList","children":[{"initializedField":{"name":"_raw","refId":"serialization/_LazyList/_raw"},"ref":{"name":"List","refId":"dart.core/List"},"id":"_raw","name":"_raw","kind":"param","isPrivate":true},{"initializedField":{"name":"_reader","refId":"serialization/_LazyList/_reader"},"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"_reader","name":"_reader","kind":"param","isPrivate":true}],"kind":"constructor","line":"524"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis provides an implementation of List that wraps a list which may\ncontain references to (potentially) non-inflated objects. If these\nare accessed it will inflate them. This allows us to pass something that\nlooks like it's just a list of objects to a [CustomRule] without needing\nto inflate all the references in advance.\n","isPrivate":true,"line":"523"},{"interfaces":[{"name":"Map","refId":"dart.core/Map"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"_LazyMap","name":"_LazyMap","children":[{"isOperator":true,"id":"[]1()","name":"[]","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"492"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"containsKey1()","name":"containsKey","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"497"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"containsValue1()","name":"containsValue","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"502"},{"returnType":{"name":"void","refId":"void"},"id":"forEach1()","name":"forEach","children":[{"id":"f","name":"f","kind":"param"}],"kind":"method","line":"504"},{"id":"_throw0()","name":"_throw","kind":"method","isPrivate":true,"line":"507"},{"isOperator":true,"id":"[]=2()","name":"[]=","children":[{"id":"x","name":"x","kind":"param"},{"id":"y","name":"y","kind":"param"}],"kind":"method","line":"510"},{"id":"putIfAbsent2()","name":"putIfAbsent","children":[{"id":"x","name":"x","kind":"param"},{"id":"y","name":"y","kind":"param"}],"kind":"method","line":"511"},{"id":"remove1()","name":"remove","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","line":"512"},{"id":"clear0()","name":"clear","kind":"method","line":"513"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","line":"494"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEmpty","name":"isEmpty","kind":"property","line":"495"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"keys","name":"keys","kind":"property","line":"496"},{"id":"_inflated","name":"_inflated","kind":"property","isPrivate":true,"line":"501"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"values","name":"values","kind":"property","line":"503"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map"},"id":"_raw","name":"_raw","kind":"variable","isPrivate":true,"line":"488"},{"isFinal":true,"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"_reader","name":"_reader","kind":"variable","isPrivate":true,"line":"489"},{"id":"_LazyMap2()","name":"_LazyMap","children":[{"initializedField":{"name":"_raw","refId":"serialization/_LazyMap/_raw"},"ref":{"name":"Map","refId":"dart.core/Map"},"id":"_raw","name":"_raw","kind":"param","isPrivate":true},{"initializedField":{"name":"_reader","refId":"serialization/_LazyMap/_reader"},"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"_reader","name":"_reader","kind":"param","isPrivate":true}],"kind":"constructor","line":"486"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis provides an implementation of Map that wraps a list which may\ncontain references to (potentially) non-inflated objects. If these\nare accessed it will inflate them. This allows us to pass something that\nlooks like it's just a list of objects to a [CustomRule] without needing\nto inflate all the references in advance.\n","isPrivate":true,"line":"485"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"isAbstract":true,"id":"CustomRule","name":"CustomRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"appliesTo2()","name":"appliesTo","children":[{"id":"instance","name":"instance","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","line":"426"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"getState1()","name":"getState","children":[{"id":"instance","name":"instance","kind":"param"}],"kind":"method","comment":"\nSubclasses should implement this to return a list of the important fields\nin the object. The order of the fields doesn't matter, except that the\ncreate and setState methods need to know how to use it.\n","line":"433"},{"id":"create1()","name":"create","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"state","name":"state","kind":"param"}],"kind":"method","comment":"\nGiven a [List] of the object's [state], re-create the object. This should\ndo the minimum needed to create the object, just calling the constructor.\nSetting the remaining state of the object should be done in the [setState]\nmethod, which will be called only once all the objects are created, so\nit won't cause problems with cycles.\n","line":"442"},{"returnType":{"name":"void","refId":"void"},"id":"setState2()","name":"setState","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"state","name":"state","kind":"param"}],"kind":"method","comment":"\nSet any state in [object] which wasn't set in the constructor. Between\nthis method and [create] all of the information in [state] should be set\nin the new object.\n","line":"449"},{"id":"extractState3()","name":"extractState","children":[{"id":"instance","name":"instance","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"451"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"459"},{"returnType":{"name":"void","refId":"void"},"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"id":"state","name":"state","kind":"param"},{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"461"},{"id":"hasVariableLengthEntries","name":"hasVariableLengthEntries","kind":"property","line":"468"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis provides an abstract superclass for writing your own rules specific to\na class. It makes some assumptions about behaviour, and so can have a\nsimpler set of methods that need to be implemented in order to subclass it.\n\n","line":"416"},{"superclass":{"name":"NamedObjectRule","refId":"serialization/NamedObjectRule"},"id":"MirrorRule","name":"MirrorRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","line":"394"},{"id":"nameFor2()","name":"nameFor","children":[{"ref":{"name":"DeclarationMirror","refId":"dart.mirrors/DeclarationMirror"},"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","line":"395"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"397"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles the special case of Mirrors. It stores the mirror by its\nqualifiedName and attempts to look it up in both the namedObjects\ncollection, or if it's not found there, by looking it up in the mirror\nsystem. When reading, the user is responsible for supplying the appropriate\nvalues in [namedObjects] or in the [externals] paramter to\n[Serialization.read].\n","line":"393"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"NamedObjectRule","name":"NamedObjectRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"\nReturn true if this rule applies to the object. Checked by looking up\nin the namedObjects collection.\n","line":"353"},{"id":"extractState3()","name":"extractState","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"Extract the state of the named objects as just the object itself. ","line":"358"},{"id":"flatten2()","name":"flatten","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"When we flatten the state we save it as the name. ","line":"370"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"Look up the named object and return it. ","line":"375"},{"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"id":"state","name":"state","kind":"param"},{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"Set any non-essential state on the object. For this rule, a no-op. ","line":"379"},{"id":"nameFor2()","name":"nameFor","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"Return the name for this object in the Writer. ","line":"382"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things we can't pass directly, but only by reference.\nIf objects are listed in the namedObjects in the writer or serialization,\nit will save the name rather than saving the state.\n","line":"348"},{"superclass":{"name":"CustomRule","refId":"serialization/CustomRule"},"id":"ClosureRule","name":"ClosureRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"331"},{"id":"getState1()","name":"getState","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","line":"333"},{"id":"create1()","name":"create","children":[{"id":"state","name":"state","kind":"param"}],"kind":"method","line":"335"},{"id":"setState2()","name":"setState","children":[{"id":"object","name":"object","kind":"param"},{"id":"state","name":"state","kind":"param"}],"kind":"method","line":"337"},{"isFinal":true,"ref":{"name":"Type","refId":"dart.core/Type"},"id":"type","name":"type","kind":"variable","line":"312"},{"ref":{"name":"ConstructType","refId":"serialization/ConstructType"},"id":"construct","name":"construct","kind":"variable","line":"315"},{"ref":{"name":"GetStateType","refId":"serialization/GetStateType"},"id":"getStateFunction","name":"getStateFunction","kind":"variable","line":"318"},{"ref":{"name":"NonEssentialStateType","refId":"serialization/NonEssentialStateType"},"id":"setNonEssentialState","name":"setNonEssentialState","kind":"variable","line":"321"},{"id":"ClosureRule4()","name":"ClosureRule","children":[{"initializedField":{"name":"type","refId":"serialization/ClosureRule/type"},"ref":{"name":"Type","refId":"dart.core/Type"},"id":"type","name":"type","kind":"param"},{"initializedField":{"name":"getStateFunction","refId":"serialization/ClosureRule/getStateFunction"},"ref":{"name":"GetStateType","refId":"serialization/GetStateType"},"id":"getStateFunction","name":"getStateFunction","kind":"param"},{"initializedField":{"name":"construct","refId":"serialization/ClosureRule/construct"},"ref":{"name":"ConstructType","refId":"serialization/ConstructType"},"id":"construct","name":"construct","kind":"param"},{"initializedField":{"name":"setNonEssentialState","refId":"serialization/ClosureRule/setNonEssentialState"},"ref":{"name":"NonEssentialStateType","refId":"serialization/NonEssentialStateType"},"id":"setNonEssentialState","name":"setNonEssentialState","kind":"param","line":"329"}],"kind":"constructor","comment":"\nCreate a ClosureToMapRule for the given [type] which gets an object's\nstate by calling [getState], creates a new object by calling [construct]\nand sets the new object's state by calling [setNonEssentialState].\n","line":"328"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis is a rule where the extraction and creation are hard-coded as\nclosures. The result is expected to be a map indexed by field name.\n","line":"309"},{"returnType":{"name":"void","refId":"void"},"id":"NonEssentialStateType","name":"NonEssentialStateType","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"m","name":"m","kind":"param"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the state-setting closure used in ClosureToMapRule. ","line":"303"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"GetStateType","name":"GetStateType","children":[{"id":"object","name":"object","kind":"param"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the state-getting closure used in ClosureToMapRule. ","line":"300"},{"id":"ConstructType","name":"ConstructType","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"m","name":"m","kind":"param"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the object construction closure used in ClosureRule. ","line":"297"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"PrimitiveRule","name":"PrimitiveRule","children":[{"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"275"},{"id":"extractState3()","name":"extractState","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"278"},{"id":"flatten2()","name":"flatten","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","line":"279"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"280"},{"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"id":"object","name":"object","kind":"param"},{"id":"_","name":"_","kind":"param","isPrivate":true},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"281"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"shouldUseReferenceFor2()","name":"shouldUseReferenceFor","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nIndicate whether we should save pointers to this object as references\nor store the object directly. For primitives this depends on the format,\nso we delegate to the writer.\n","line":"290"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"storesStateAsPrimitives","name":"storesStateAsPrimitives","kind":"property","line":"283"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"hasVariableLengthEntries","name":"hasVariableLengthEntries","kind":"property","line":"293"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles primitive types, defined as those that we can normally\nrepresent directly in the output format. We hard-code that to mean\nnum, String, and bool.\n","line":"274"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"MapRule","name":"MapRule","children":[{"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"199"},{"id":"extractState3()","name":"extractState","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"map","name":"map","kind":"param"},{"id":"f","name":"f","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"203"},{"id":"flatten2()","name":"flatten","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"state","name":"state","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"\nChange the keys and values of [state] into references in [writer].\nIf [state] is a map whose keys are all strings then we leave the keys\nas is so that JSON formats will be more readable. If the keys are\narbitrary then we need to turn them into references and replace the\nstate with a new Map whose keys are the references.\n","line":"220"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"236"},{"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"newMap","name":"newMap","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"240"},{"returnType":{"name":"void","refId":"void"},"id":"inflateNonEssentialFromList3()","name":"inflateNonEssentialFromList","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"state","name":"state","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"newMap","name":"newMap","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"248"},{"returnType":{"name":"void","refId":"void"},"id":"inflateNonEssentialFromMap3()","name":"inflateNonEssentialFromMap","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"state","name":"state","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"newMap","name":"newMap","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"260"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"storesStateAsMaps","name":"storesStateAsMaps","kind":"property","line":"201"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"hasVariableLengthEntries","name":"hasVariableLengthEntries","kind":"property","line":"266"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things that implement Map. It will recreate them as\nwhatever the default implemenation of Map is on the target platform. If a\nmap has string keys it will attempt to retain it as a map for JSON formats,\notherwise it will store it as a list of references to keys and values.\n","line":"197"},{"superclass":{"name":"ListRule","refId":"serialization/ListRule"},"id":"ListRuleEssential","name":"ListRuleEssential","children":[{"id":"inflateEssential2()","name":"inflateEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","comment":"Create the new List and also inflate all of its contents. ","line":"179"},{"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"id":"state","name":"state","kind":"param"},{"id":"newList","name":"newList","kind":"param"},{"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"Does nothing, because all the work has been done in inflateEssential. ","line":"186"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"mustBePrimary","name":"mustBePrimary","kind":"property","line":"188"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis is a subclass of ListRule where all of the list's contents are\nconsidered essential state. This is needed if an object X contains a List L,\nbut it expects L's contents to be fixed when X's constructor is called.\n","line":"176"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"ListRule","name":"ListRule","children":[{"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"141"},{"returnType":{"name":"List","refId":"dart.core/List"},"id":"extractState3()","name":"extractState","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"list","name":"list","kind":"param"},{"id":"f","name":"f","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","line":"145"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"154"},{"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"state","name":"state","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"newList","name":"newList","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"158"},{"returnType":{"name":"void","refId":"void"},"id":"populateContents3()","name":"populateContents","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"state","name":"state","kind":"param"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"newList","name":"newList","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"162"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"storesStateAsLists","name":"storesStateAsLists","kind":"property","line":"143"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"hasVariableLengthEntries","name":"hasVariableLengthEntries","kind":"property","line":"168"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things that implement List. It will recreate them as\nwhatever the default implemenation of List is on the target platform.\n","line":"139"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"SerializationRule","name":"SerializationRule","children":[{"isSetter":true,"returnType":{"name":"void","refId":"void"},"id":"number=1()","name":"number=","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","line":"30"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"appliesTo2()","name":"appliesTo","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","line":"40"},{"id":"extractState3()","name":"extractState","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","children":[{"id":"value","name":"value","uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"param","line":"48"}],"uri":"sdk/lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nThis extracts the state from the object, calling [f] for each value\nas it is extracted, and returning an object representing the whole\nstate at the end. The state that results will still have direct\npointers to objects, rather than references.\n","line":"48"},{"id":"flatten2()","name":"flatten","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"\nGiven the variables representing the state of an object, flatten it\nby turning object pointers into Reference objects where needed. This\ndestructively modifies the state object.\n\nThis has a default implementation which assumes that object is indexable,\nso either conforms to Map or List. Subclasses may override to do something\ndifferent, including returning a new state object to be used in place\nof the original.\n","line":"73"},{"id":"inflateEssential2()","name":"inflateEssential","children":[{"id":"state","name":"state","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"\nCreate the new object corresponding to [state] using the rules\nfrom [reader]. This may involve recursively inflating \"essential\"\nreferences in the state, which are those that are required for the\nobject's constructor. It is up to the rule what state is considered\nessential.\n","line":"103"},{"id":"inflateNonEssential3()","name":"inflateNonEssential","children":[{"id":"state","name":"state","kind":"param"},{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"id":"reader","name":"reader","kind":"param"}],"kind":"method","comment":"\nThe [object] has already been created. Set any of its non-essential\nvariables from the representation in [state]. Where there are references\nto other objects they are resolved in the context of [reader].\n","line":"110"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"shouldUseReferenceFor2()","name":"shouldUseReferenceFor","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"method","comment":"\nIf we have [object] as part of our state, should we represent that\ndirectly, or should we make a reference for it. By default, true.\nThis may also delegate to [writer].\n","line":"117"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"number","name":"number","kind":"property","comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","line":"24"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"storesStateAsLists","name":"storesStateAsLists","kind":"property","comment":"\nAllows rules to tell us how they expect to store their state. If this\nisn't specified we can also just look at the data to tell.\n","line":"54"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"storesStateAsMaps","name":"storesStateAsMaps","kind":"property","line":"55"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"storesStateAsPrimitives","name":"storesStateAsPrimitives","kind":"property","line":"56"},{"id":"mustBePrimary","name":"mustBePrimary","kind":"property","comment":"Return true if this rule should only be applied when we are the first\nrule found that applies to this object. This may or may not be a hack\nthat will disappear once we have better support for multiple rules.\nWe want to have multiple different rules that apply to the same object. We\nalso want to have multiple different rules that might exclusively apply\nto the same object. So, we want either ListRule or ListRuleEssential, and\nonly one of them can be there. But on the other hand, we may want both\nListRule and BasicRule. So we identify the kinds of rules that can share.\nIf mustBePrimary returns true, then this rule will only be chosen if no\nother rule has been found yet. This means that the ordering of rules in\nthe serialization is significant, which is unpleasant, but we'll have\nto see how bad it is.\n","line":"94"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"hasVariableLengthEntries","name":"hasVariableLengthEntries","kind":"property","comment":"\nReturn true if the data this rule returns is variable length, so a\nlength needs to be written for it if the format requires that. Return\nfalse if the results are always the same length.\n","line":"124"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"dataLength","name":"dataLength","kind":"property","comment":"\nIf the data is fixed length, return it here. The format may or may not\nmake use of this, depending on whether it already has enough information\nto determine the length on its own. If [hasVariableLengthEntries] is true\nthis is ignored.\n","line":"132"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"_number","name":"_number","kind":"variable","isPrivate":true,"line":"18"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThe abstract superclass for serialization rules.\n","line":"13"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"DesignatedRuleForObject","name":"DesignatedRuleForObject","children":[{"id":"possibleRules1()","name":"possibleRules","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"rules","name":"rules","kind":"param"}],"kind":"method","line":"614"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"rulePredicate","name":"rulePredicate","kind":"variable","line":"609"},{"isFinal":true,"id":"target","name":"target","kind":"variable","line":"610"},{"id":"DesignatedRuleForObject2()","name":"DesignatedRuleForObject","children":[{"initializedField":{"name":"target","refId":"serialization/DesignatedRuleForObject/target"},"id":"target","name":"target","kind":"param"},{"initializedField":{"name":"rulePredicate","refId":"serialization/DesignatedRuleForObject/rulePredicate"},"ref":{"name":"Function","refId":"dart.core/Function"},"id":"rulePredicate","name":"rulePredicate","kind":"param"}],"kind":"constructor","line":"612"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis is used during tracing to indicate that an object should be processed\nusing a particular rule, rather than the one that might ordinarily be\nfound for it. This normally only makes sense if the object is uniquely\nreferenced, and is a more or less internal collection. See ListRuleEssential\nfor an example. It knows how to return its object and how to filter.\n","line":"608"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Reference","name":"Reference","children":[{"id":"inflated0()","name":"inflated","kind":"method","comment":"\nReturn the thing this reference points to. Assumes that we have a valid\nparent and that it is a Reader, as inflating is not meaningful when\nwriting.\n","line":"577"},{"id":"toJson0()","name":"toJson","kind":"method","comment":"\nConvert the reference to a map in JSON format. This is specific to the\ncustom JSON format we define, and must be consistent with the\n[asReference] method.\n","line":"586"},{"id":"writeToList1()","name":"writeToList","children":[{"ref":{"name":"List","refId":"dart.core/List"},"id":"list","name":"list","kind":"param"}],"kind":"method","comment":"Write our information to [list]. Useful in writing to flat formats.","line":"593"},{"id":"toString0()","name":"toString","kind":"method","line":"598"},{"isFinal":true,"ref":{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"},"id":"parent","name":"parent","kind":"variable","line":"557"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"ruleNumber","name":"ruleNumber","kind":"variable","line":"559"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"objectNumber","name":"objectNumber","kind":"variable","line":"561"},{"id":"Reference3()","name":"Reference","children":[{"initializedField":{"name":"parent","refId":"serialization/Reference/parent"},"ref":{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"},"id":"parent","name":"parent","kind":"param"},{"initializedField":{"name":"ruleNumber","refId":"serialization/Reference/ruleNumber"},"ref":{"name":"int","refId":"dart.core/int"},"id":"ruleNumber","name":"ruleNumber","kind":"param"},{"initializedField":{"name":"objectNumber","refId":"serialization/Reference/objectNumber"},"ref":{"name":"int","refId":"dart.core/int"},"id":"objectNumber","name":"objectNumber","kind":"param"}],"kind":"constructor","line":"563"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nAny pointers to objects that can't be represented directly in the\nserialization format has to be stored as a reference. A reference encodes\nthe rule number of the rule that saved it in the Serialization that was used\nfor writing, and the object number within that rule.\n","line":"555"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Trace","name":"Trace","children":[{"id":"addRoot1()","name":"addRoot","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","line":"510"},{"id":"trace1()","name":"trace","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"A convenience method to add a single root and trace it in one step. ","line":"515"},{"id":"traceAll0()","name":"traceAll","kind":"method","comment":"\nProcess all of the objects reachable from our roots via state that the\nserialization rules access.\n","line":"524"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"hasProcessed1()","name":"hasProcessed","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"\nHas this object been seen yet? We test for this by checking if the\nwriter has a reference for it. See comment for _hasIndexFor.\n","line":"536"},{"id":"note1()","name":"note","children":[{"id":"value","name":"value","kind":"param"}],"kind":"method","comment":"Note that we've seen [value], and add it to the queue to be processed. ","line":"541"},{"isFinal":true,"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"variable","line":"497"},{"isFinal":true,"ref":{"name":"Queue","refId":"dart.collection/Queue"},"id":"queue","name":"queue","kind":"variable","line":"503"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"roots","name":"roots","kind":"variable","line":"506"},{"id":"Trace1()","name":"Trace","children":[{"initializedField":{"name":"writer","refId":"serialization/Trace/writer"},"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"writer","name":"writer","kind":"param"}],"kind":"constructor","line":"508"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis represents the transitive closure of the referenced objects to be\nused for serialization. It works closely in conjunction with the Writer,\nand is kept as a separate object primarily for the possibility of wanting\nto plug in different sorts of tracing rules.\n","line":"493"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"_Sentinel","name":"_Sentinel","children":[{"id":"_Sentinel0()","name":"_Sentinel","kind":"constructor","line":"484"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis serves as a marker to indicate a object that is in the process of\nbeing de-serialized. So if we look for an object slot and find one of these,\nwe know we've hit a cycle.\n","isPrivate":true,"line":"483"},{"interfaces":[{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Reader","name":"Reader","children":[{"id":"objectNamed2()","name":"objectNamed","children":[{"id":"key","name":"key","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"ifAbsent","name":"ifAbsent","kind":"param"}],"kind":"method","comment":"\nLook up the reference to an external object. This can be held either in\nthe reader-specific list of externals or in the serializer's\n","line":"312"},{"returnType":{"name":"void","refId":"void"},"id":"keyNotFound1()","name":"keyNotFound","children":[{"id":"key","name":"key","kind":"param"}],"kind":"method","line":"321"},{"isSetter":true,"returnType":{"name":"void","refId":"void"},"id":"data=1()","name":"data=","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"id":"newData","name":"newData","kind":"param"}],"kind":"method","comment":"\nInternal use only, for testing purposes. Set the data for this reader\nto a List of Lists whose size must match the number of rules.\n","line":"337"},{"id":"read2()","name":"read","children":[{"id":"rawInput","name":"rawInput","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"defaultValue":"const{}","isOptional":true,"id":"externals","name":"externals","kind":"param"}],"kind":"method","comment":"\nThis is the primary method for a [Reader]. It takes the input data,\ndecodes it according to [format] and returns the root object.\n","line":"346"},{"returnType":{"name":"void","refId":"void"},"id":"readRules1()","name":"readRules","children":[{"id":"newRules","name":"newRules","kind":"param"}],"kind":"method","comment":"\nIf the data we are reading from has rules written to it, read them back\nand set them as the rules we will use.\n","line":"358"},{"id":"inflateForRule1()","name":"inflateForRule","children":[{"id":"rule","name":"rule","kind":"param"}],"kind":"method","comment":"\nInflate all of the objects for [rule]. Does the essential state for all\nobjects first, then the non-essential state. This avoids cycles in\nnon-essential state, because all the objects will have already been\ncreated.\n","line":"375"},{"id":"inflateOne3()","name":"inflateOne","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"},{"id":"position","name":"position","kind":"param"},{"id":"state","name":"state","kind":"param"}],"kind":"method","comment":"\nCreate a new object, based on [rule] and [state], which will\nbe stored in [position] in the storage for [rule]. This will\nfollow references and recursively inflate them, leaving Sentinel objects\nto detect cycles.\n","line":"391"},{"id":"inflateReference1()","name":"inflateReference","children":[{"id":"possibleReference","name":"possibleReference","kind":"param"}],"kind":"method","comment":"\nThe parameter [possibleReference] might be a reference. If it isn't, just\nreturn it. If it is, then inflate the target of the reference and return\nthe resulting object.\n","line":"412"},{"id":"resolveReference1()","name":"resolveReference","children":[{"id":"reference","name":"reference","kind":"param"}],"kind":"method","comment":"Return the object pointed to by [reference]. ","line":"425"},{"id":"_objectFor1()","name":"_objectFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"id":"reference","name":"reference","kind":"param"}],"kind":"method","comment":"\nGiven [reference], return what we have stored as an object for it. Note\nthat, depending on the current state, this might be null or a Sentinel.\n","isPrivate":true,"line":"431"},{"id":"allObjectsForRule1()","name":"allObjectsForRule","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"}],"kind":"method","comment":"Given [rule], return the storage for its objects. ","line":"435"},{"id":"_stateFor1()","name":"_stateFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"id":"reference","name":"reference","kind":"param"}],"kind":"method","comment":"Given [reference], return the the state we have stored for it. ","isPrivate":true,"line":"438"},{"returnType":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"ruleFor1()","name":"ruleFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"id":"reference","name":"reference","kind":"param"}],"kind":"method","comment":"Given a reference, return the rule it references. ","line":"442"},{"returnType":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"_primitiveRule0()","name":"_primitiveRule","kind":"method","comment":"\nReturn the primitive rule we are using. This is an ugly mechanism to\nsupport the extra information to reconstruct objects in the\n[SimpleJsonFormat].\n","isPrivate":true,"line":"450"},{"id":"asReference3()","name":"asReference","children":[{"id":"anObject","name":"anObject","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"defaultValue":"doNothing","isOptional":true,"id":"ifReference","name":"ifReference","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"defaultValue":"doNothing","isOptional":true,"id":"ifNotReference","name":"ifNotReference","kind":"param","line":"466"}],"kind":"method","comment":"\nGiven a possible reference [anObject], call either [ifReference] or\n[ifNotReference], depending if it's a reference or not. This is the\nprimary place that knows about the serialized representation of a\nreference.\n","line":"465"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"id":"rules","name":"rules","kind":"property","comment":"\nReturn the list of rules to be used when writing. These come from the\n[serialization].\n","line":"330"},{"ref":{"name":"Serialization","refId":"serialization/Serialization"},"id":"serialization","name":"serialization","kind":"variable","line":"261"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"selfDescribing","name":"selfDescribing","kind":"variable","line":"267"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"id":"_data","name":"_data","kind":"variable","isPrivate":true,"line":"277"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"id":"objects","name":"objects","kind":"variable","line":"284"},{"ref":{"name":"Format","refId":"serialization/Format"},"id":"format","name":"format","kind":"variable","line":"286"},{"ref":{"name":"Map","refId":"dart.core/Map"},"id":"namedObjects","name":"namedObjects","kind":"variable","line":"306"},{"id":"Reader2()","name":"Reader","children":[{"initializedField":{"name":"serialization","refId":"serialization/Reader/serialization"},"ref":{"name":"Serialization","refId":"serialization/Serialization"},"id":"serialization","name":"serialization","kind":"param"},{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"id":"newFormat","name":"newFormat","kind":"param"}],"kind":"constructor","comment":"\nCreates a new [Reader] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state related to\na particular read or write operation, so the same one can be used\nfor multiple different Writers/Readers.\n","line":"294"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThe main class responsible for reading. It holds\nonto the necessary state and to the objects that have been inflated.\n","line":"253"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"ReaderOrWriter","name":"ReaderOrWriter","children":[{"id":"resolveReference1()","name":"resolveReference","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"id":"ref","name":"ref","kind":"param"}],"kind":"method","comment":"\nReturn the object, or state, that ref points to, depending on which\nwe're generating.\n","line":"246"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"id":"rules","name":"rules","kind":"property","comment":"Return the list of serialization rules we are using.","line":"240"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nAn abstract class for Reader and Writer, which primarily exists so we can\ntype things that will refer to one or the other, depending on which\noperation we're doing.\n","line":"238"},{"interfaces":[{"name":"ReaderOrWriter","refId":"serialization/ReaderOrWriter"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Writer","name":"Writer","children":[{"id":"write1()","name":"write","children":[{"id":"anObject","name":"anObject","kind":"param"}],"kind":"method","comment":"\nThis is the main API for a [Writer]. It writes the objects and returns\nthe serialized representation, as determined by [format].\n","line":"74"},{"returnType":{"name":"void","refId":"void"},"id":"_flatten0()","name":"_flatten","kind":"method","comment":"\nGiven that we have fully populated the list of [states], and more\nimportantly, the list of [references], go through each state and turn\nanything that requires a [Reference] into one. Since only the rules\nknow the representation they use for state, delegate to them.\n","isPrivate":true,"line":"87"},{"returnType":{"name":"void","refId":"void"},"id":"_process2()","name":"_process","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Trace","refId":"serialization/Trace"},"id":"trace","name":"trace","kind":"param"}],"kind":"method","comment":"\nAs the [trace] processes each object, it will call this method on us.\nWe find the rules for this object, and record the state of the object\nas determined by each rule.\n","isPrivate":true,"line":"107"},{"returnType":{"name":"void","refId":"void"},"id":"_record2()","name":"_record","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"}],"kind":"method","comment":"\nRecord the state of [object] as determined by [rule] and keep\ntrack of it. Generate a [Reference] for this object if required.\nWhen it's required is up to the particular rule, but generally everything\ngets a reference except a primitive.\nNote that at this point the states are just the same as the fields of the\nobject, and haven't been flattened.\n","isPrivate":true,"line":"122"},{"id":"serializedRules0()","name":"serializedRules","kind":"method","comment":"\nReturns a serialized version of the [SerializationRule]s used to write\nthe data, if [selfDescribing] is true, otherwise returns null.\n","line":"143"},{"returnType":{"name":"void","refId":"void"},"id":"_addStateForRule2()","name":"_addStateForRule","children":[{"id":"eachRule","name":"eachRule","kind":"param"},{"id":"state","name":"state","kind":"param"}],"kind":"method","comment":"Record a [state] entry for a particular rule. ","isPrivate":true,"line":"152"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"_nextObjectNumberFor1()","name":"_nextObjectNumberFor","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"}],"kind":"method","comment":"Find what the object number for the thing we're about to add will be.","isPrivate":true,"line":"158"},{"returnType":{"name":"void","refId":"void"},"id":"_growStates1()","name":"_growStates","children":[{"id":"eachRule","name":"eachRule","kind":"param"}],"kind":"method","comment":"\nWe store the states in a List, indexed by rule number. But rules can be\ndynamically added, so we may have to grow the list.\n","isPrivate":true,"line":"167"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_hasIndexFor1()","name":"_hasIndexFor","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"\nReturn true if we have an object number for this object. This is used to\ntell if we have processed the object or not. This relies on checking if we\nhave a reference or not. That saves some space by not having to keep track\nof simple objects, but means that if someone refers to the identical string\nfrom several places, we will process it several times, and store it\nseveral times. That seems an acceptable tradeoff, and in cases where it\nisn't, it's possible to apply a rule for String, or even for Strings larger\nthan x, which gives them references.\n","isPrivate":true,"line":"181"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"_objectNumberFor1()","name":"_objectNumberFor","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"\nGiven an object, find what number it has. The number is valid only in\nthe context of a particular rule, and if the rule has more than one,\nthis will return the one for the primary rule, defined as the one that\nis listed in its canonical reference.\n","isPrivate":true,"line":"191"},{"id":"_rootReferences0()","name":"_rootReferences","kind":"method","comment":"\nReturn a list of [Reference] objects pointing to our roots. This will be\nstored in the output under \"roots\" in the default format.\n","isPrivate":true,"line":"200"},{"id":"_referenceFor1()","name":"_referenceFor","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"\nGiven an object, return a reference for it if one exists. If there's\nno reference, return the object itself. Once we have finished the tracing\nstep, all objects that should have a reference (roughly speaking,\nnon-primitives) can be relied on to have a reference.\n","isPrivate":true,"line":"208"},{"id":"hasNameFor1()","name":"hasNameFor","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"\nReturn true if the [namedObjects] collection has a reference to [object].\n","line":"219"},{"id":"nameFor1()","name":"nameFor","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"\nReturn the name we have for this object in the [namedObjects] collection.\n","line":"224"},{"id":"stateForReference1()","name":"stateForReference","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"id":"r","name":"r","kind":"param"}],"kind":"method","line":"227"},{"id":"resolveReference1()","name":"resolveReference","children":[{"id":"reference","name":"reference","kind":"param"}],"kind":"method","comment":"Return the state pointed to by [reference]. ","line":"230"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"id":"rules","name":"rules","kind":"property","comment":"Return the list of rules we use. ","line":"56"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"shouldUseReferencesForPrimitives","name":"shouldUseReferencesForPrimitives","kind":"property","comment":"\nShould we store primitive objects directly or create references for them.\nThat depends on which format we're using, so a flat format will want\nreferences, but the Map format can store them directly.\n","line":"136"},{"isFinal":true,"ref":{"name":"Serialization","refId":"serialization/Serialization"},"id":"serialization","name":"serialization","kind":"variable","line":"21"},{"ref":{"name":"Trace","refId":"serialization/Trace"},"id":"trace","name":"trace","kind":"variable","line":"25"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"selfDescribing","name":"selfDescribing","kind":"variable","line":"32"},{"ref":{"name":"Format","refId":"serialization/Format"},"id":"format","name":"format","kind":"variable","line":"34"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Reference","refId":"serialization/Reference"}]},"id":"references","name":"references","kind":"variable","line":"42"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"id":"states","name":"states","kind":"variable","line":"53"},{"id":"Writer2()","name":"Writer","children":[{"initializedField":{"name":"serialization","refId":"serialization/Writer/serialization"},"ref":{"name":"Serialization","refId":"serialization/Serialization"},"id":"serialization","name":"serialization","kind":"param"},{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"id":"newFormat","name":"newFormat","kind":"param"}],"kind":"constructor","comment":"\nCreates a new [Writer] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state\nrelated to a particular read/write, so the same one can be used\nfor multiple different Readers/Writers.\n","line":"64"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis writes out the state of the objects to an external format. It holds\nall of the intermediate state needed. The primary API for it is the\n[write] method.\n","line":"16"},{"interfaces":[{"name":"Exception","refId":"dart.core/Exception"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isThrowable":true,"id":"SerializationException","name":"SerializationException","children":[{"id":"toString0()","name":"toString","kind":"method","line":"475"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"variable","line":"473"},{"id":"SerializationException1()","name":"SerializationException","children":[{"initializedField":{"name":"message","refId":"serialization/SerializationException/message"},"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"474"}],"kind":"class","comment":"\nAn exception class for errors during serialization.\n","line":"472"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Serialization","name":"Serialization","children":[{"isSetter":true,"id":"selfDescribing=1()","name":"selfDescribing=","children":[{"id":"x","name":"x","kind":"param"}],"kind":"method","comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","line":"253"},{"returnType":{"name":"BasicRule","refId":"serialization/BasicRule"},"id":"addRuleFor5()","name":"addRuleFor","children":[{"id":"instanceOfType","name":"instanceOfType","kind":"param","line":"297"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"constructor","name":"constructor","kind":"param","line":"298"},{"ref":{"name":"List","refId":"dart.core/List"},"isNamed":true,"isOptional":true,"id":"constructorFields","name":"constructorFields","kind":"param","line":"299"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"isNamed":true,"isOptional":true,"id":"fields","name":"fields","kind":"param","line":"300"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"isNamed":true,"isOptional":true,"id":"excludeFields","name":"excludeFields","kind":"param","line":"301"}],"kind":"method","comment":"\nCreate a [BasicRule] rule for the type of\n[instanceOfType]. Optionally\nallows specifying a [constructor] name, the list of [constructorFields],\nand the list of [fields] not used in the constructor. Returns the new\nrule. Note that [BasicRule] uses reflection, and so will not work with the\ncurrent state of dartj2s. If you need to run there, consider using\n[CustomRule] instead.\n\nIf the optional parameters aren't specified, the default constructor will\nbe used, and the list of fields will be computed. Alternatively, you can\nomit [fields] and provide [excludeFields], which will then compute the\nlist of fields specifically excluding those listed.\n\nThe fields can be actual public fields, but can also be getter/setter\npairs or getters whose value is provided in the constructor. For the\n[constructorFields] they can also be arbitrary objects. Anything that is\nnot a String will be treated as a constant value to be used in any\nconstruction of these objects.\n\nIf the list of fields is computed, fields from the superclass will be\nincluded. However, each subclass needs its own rule, since the constructors\nare not inherited, and so may need to be specified separately for each\nsubclass.\n","line":"296"},{"returnType":{"name":"void","refId":"void"},"id":"addDefaultRules0()","name":"addDefaultRules","kind":"method","comment":"Set up the default rules, for lists and primitives. ","line":"313"},{"returnType":{"name":"void","refId":"void"},"id":"addRule1()","name":"addRule","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"id":"rule","name":"rule","kind":"param"}],"kind":"method","comment":"\nAdd a new SerializationRule [rule]. The addRuleFor method will probably\nhandle most simple cases, but for adding an arbitrary rule, including\na SerializationRule subclass which you have created, you can use this\nmethod.\n","line":"328"},{"id":"write2()","name":"write","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"id":"object","name":"object","kind":"param"},{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"id":"format","name":"format","kind":"param"}],"kind":"method","comment":"\nThis writes out an object graph rooted at [object] and returns the result.\nThe [format] parameter determines the form of the result. The default\nformat returns a String in [json] format.\n","line":"338"},{"returnType":{"name":"Writer","refId":"serialization/Writer"},"id":"newWriter1()","name":"newWriter","children":[{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"id":"format","name":"format","kind":"param"}],"kind":"method","comment":"\nReturn a new [Writer] object for this serialization. This is useful if you\nwant to do something more complex with the writer than just returning\nthe final result.\n","line":"347"},{"id":"read2()","name":"read","children":[{"id":"input","name":"input","kind":"param"},{"ref":{"name":"Map","refId":"dart.core/Map"},"defaultValue":"const{}","isOptional":true,"id":"externals","name":"externals","kind":"param"}],"kind":"method","comment":"\nRead the serialized data from [input] and return the root object\nfrom the result. The [input] can be of any type that the [Format]\nreads/writes, but normally will be a [List], [Map], or a simple type.\nIf there are objects that need to be resolved\nin the current context, they should be provided in [externals] as a\nMap from names to values. In particular, in the current implementation\nany class mirrors needed should be provided in [externals] using the\nclass name as a key. In addition to the [externals] map provided here,\nvalues will be looked up in the [namedObjects] map.\n","line":"361"},{"returnType":{"name":"Reader","refId":"serialization/Reader"},"id":"newReader1()","name":"newReader","children":[{"ref":{"name":"Format","refId":"serialization/Format"},"isOptional":true,"id":"format","name":"format","kind":"param"}],"kind":"method","comment":"\nReturn a new [Reader] object for this serialization. This is useful if\nyou want to do something more complex with the reader than just returning\nthe final result.\n","line":"370"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"id":"rulesFor2()","name":"rulesFor","children":[{"id":"object","name":"object","kind":"param"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"id":"w","name":"w","kind":"param"}],"kind":"method","comment":"\nReturn the list of SerializationRule that apply to [object]. For\ninternal use, but public because it's used in testing.\n","line":"376"},{"returnType":{"name":"Serialization","refId":"serialization/Serialization"},"id":"ruleSerialization0()","name":"ruleSerialization","kind":"method","comment":"\nCreate a Serialization for serializing SerializationRules. This is used\nto save the rules in a self-describing format along with the data.\nIf there are new rule classes created, they will need to be described\nhere.\n","line":"423"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_hasNameFor1()","name":"_hasNameFor","children":[{"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"Return true if our [namedObjects] collection has an entry for [object].","isPrivate":true,"line":"452"},{"id":"_nameFor2()","name":"_nameFor","children":[{"id":"object","name":"object","kind":"param"},{"isOptional":true,"id":"ifAbsent","name":"ifAbsent","kind":"param"}],"kind":"method","comment":"\nReturn the name we have for [object] in our [namedObjects] collection or\nthe result of evaluating [ifAbsent] if there is no entry.\n","isPrivate":true,"line":"461"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"rules","name":"rules","kind":"property","comment":"\nThe serialization is controlled by the list of Serialization rules. These\nare most commonly added via [addRuleFor].\n","line":"213"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"selfDescribing","name":"selfDescribing","kind":"property","comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","line":"240"},{"ref":{"name":"List","refId":"dart.core/List"},"id":"_rules","name":"_rules","kind":"variable","isPrivate":true,"line":"207"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"id":"namedObjects","name":"namedObjects","kind":"variable","line":"224"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_selfDescribing","name":"_selfDescribing","kind":"variable","isPrivate":true,"line":"232"},{"id":"Serialization0()","name":"Serialization","kind":"constructor","comment":"\nCreates a new serialization with a default set of rules for primitives\nand lists.\n","line":"259"},{"id":"Serialization.blank0()","name":"Serialization.blank","kind":"constructor","comment":"\nCreates a new serialization with no default rules at all. The most common\nuse for this is if we are reading self-describing serialized data and\nwill populate the rules from that data.\n","line":"268"}],"kind":"class","comment":"\nThis class defines a particular serialization scheme, in terms of\n[SerializationRule] instances, and supports reading and writing them.\nSee library comment for examples of usage.\n","line":"201"}],"uri":"pkg/serialization/lib/serialization.dart","kind":"library","comment":"\nThis provides a general-purpose serialization facility for Dart objects. A\n[Serialization] is defined in terms of [SerializationRule]s and supports\nreading and writing to different formats.\n\nSetup\n=====\nA simple example of usage is\n\n     var address = new Address();\n     address.street = 'N 34th';\n     address.city = 'Seattle';\n     var serialization = new Serialization()\n         ..addRuleFor(address);\n     String output = serialization.write(address);\n\nThis creates a new serialization and adds a rule for address objects. Right\nnow it has to be passed an address instance because of limitations using\nAddress as a literal. Then we ask the Serialization to write the address\nand we get back a Map which is a [json]able representation of the state of\nthe address and related objects.\n\nThe version above used reflection to automatically identify the public\nfields of the address object. We can also specify those fields explicitly.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"create\",\n           constructorFields: [\"number\", \"street\"],\n           fields: [\"city\"]);\n\nThis rule still uses reflection to access the fields, but does not try to\nidentify which fields to use, but instead uses only the \"number\" and \"street\"\nfields that we specified. We may also want to tell it to identify the\nfields, but to specifically omit certain fields that we don't want\nserialized.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"\",\n           excludeFields: [\"other\", \"stuff\"]);\n\nWriting Rules\n=============\nWe can also use a completely non-reflective rule to serialize and\nde-serialize objects. This can be more work, but it does work in\ndart2js, where mirrors are not yet implemented. We can specify this in two\nways. First, we can write our own SerializationRule class that has methods\nfor our Address class.\n\n     class AddressRule extends CustomRule {\n       bool appliesTo(instance, Writer w) => instance.runtimeType == Address;\n       getState(instance) => [instance.street, instance.city];\n       create(state) => new Address();\n       setState(Address a, List state) {\n         a.street = state[0];\n         a.city = state[1];\n       }\n     }\n\nThe class needs four different methods. The [appliesTo] method tells us if\nthe rule should be used to write an object. In this example we use a test\nbased on runtimeType. We could also use an \"is Address\" test, but if Address\nhas subclasses that would find those as well, and we want a separate rule\nfor each. The [getState] method should\nreturn all the state of the object that we want to recreate,\nand should be either a Map or a List. If you want to write to human-readable\nformats where it's useful to be able to look at the data as a map from\nfield names to values, then it's better to return it as a map. Otherwise it's\nmore efficient to return it as a list. You just need to be sure that the\n[create] and [setState] methods interpret the same way as [getState] does.\n\nThe [create] method will create the new object and return it. While it's\npossible to create the object and set all its state in this one method, that\nincreases the likelihood of problems with cycles. So it's better to use the\nminimum necessary information in [create] and do more of the work in\n[setState].\n\nThe other way to do this is not creating a subclass, but by using a\n[ClosureRule] and giving it functions for how to create\nthe address.\n\n     addressToMap(a) => {\"number\" : a.number, \"street\" : a.street,\n         \"city\" : a.city};\n     createAddress(Map m) => new Address.create(m[\"number\"], m[\"street\"]);\n     fillInAddress(Address a, Map m) => a.city = m[\"city\"];\n     var serialization = new Serialization()\n       ..addRule(\n           new ClosureRule(anAddress.runtimeType,\n               addressToMap, createAddress, fillInAddress);\n\nIn this case we have created standalone functions rather than\nmethods in a subclass and we pass them to the constructor of\n[ClosureRule]. In this case we've also had them use maps rather than\nlists for the state, but either would work as long as the rule is\nconsistent with the representation it uses. We pass it the runtimeType\nof the object, and functions equivalent to the methods on [CustomRule]\n\nConstant Values\n===============\nThere are cases where the constructor needs values that we can't easily get\nfrom the serialized object. For example, we may just want to pass null, or a\nconstant value. To support this, we can specify as constructor fields\nvalues that aren't field names. If any value isn't a String, or is a string\nthat doesn't correspond to a field name, it will be\ntreated as a constant and passed unaltered to the constructor.\n\nIn some cases a non-constructor field should not be set using field\naccess or a setter, but should be done by calling a method. For example, it\nmay not be possible to set a List field \"foo\", and you need to call an\naddFoo() method for each entry in the list. In these cases, if you are using\na BasicRule for the object you can call the setFieldWith() method.\n\n      s..addRuleFor(fooHolderInstance).setFieldWith(\"foo\",\n          (parent, value) => for (var each in value) parent.addFoo(value));\n\nWriting\n=======\nTo write objects, we use the write() method.\n\n      var output = serialization.write(someObject);\n\nBy default this uses a representation in which objects are represented as\nmaps keyed by field name, but in which references between objects have been\nconverted into Reference objects. This is then typically encoded as\na [json] string, but can also be used in other ways, e.g. sent to another\nisolate.\n\nWe can write objects in different formats by passing a [Format] object to\nthe [write] method or by getting a [Writer] object. The available formats\ninclude the default, a simple \"flat\" format that doesn't include field names,\nand a simple JSON format that produces output more suitable for talking to\nservices that expect JSON in a predefined format. Examples of these are\n\n     Map output = serialization.write(address, new SimpleMapFormat());\n     List output = serialization.write(address, new SimpleFlatFormat());\n     var output = serialization.write(address, new SimpleJsonFormat());\nOr, using a [Writer] explicitly\n     var writer = serialization.newWriter(new SimpleFlatFormat());\n     List output = writer.write(address);\n\nThese representations are not yet considered stable.\n\nReading\n=======\nTo read objects, the corresponding [read] method can be used.\n\n      Address input = serialization.read(input);\n\nWhen reading, the serialization instance doing the reading must be configured\nwith compatible rules to the one doing the writing. It's possible for the\nrules to be different, but they need to be able to read the same\nrepresentation. For most practical purposes right now they should be the\nsame. The simplest way to achieve this is by having the serialization\nvariable [selfDescribing] be true. In that case the rules themselves are also\nstored along with the serialized data, and can be read back on the receiving\nend. Note that this may not work for all rules or all formats. The\n[selfDescribing] variable is true by default, but the [SimpleJsonFormat] does\nnot support it, since the point is to provide a representation in a form\nother services might expect. Using CustomRule or ClosureRule also does not\nyet work with the [selfDescribing] variable.\n\nNamed Objects\n=============\nWhen reading, some object references should not be serialized, but should be\nconnected up to other instances on the receiving side. A notable example of\nthis is when serialization rules have been stored. Instances of BasicRule\ntake a [ClassMirror] in their constructor, and we cannot serialize those. So\nwhen we read the rules, we must provide a Map<String, Object> which maps from\nthe simple name of classes we are interested in to a [ClassMirror]. This can\nbe provided either in the [namedObjects] variable of the Serialization,\nor as an additional parameter to the reading and writing methods on the\n[Reader] or [Writer] respectively.\n\n    new Serialization()\n      ..addRuleFor(new Person(), constructorFields: [\"name\"])\n      ..namedObjects['Person'] = reflect(new Person()).type;\n","line":"183"}